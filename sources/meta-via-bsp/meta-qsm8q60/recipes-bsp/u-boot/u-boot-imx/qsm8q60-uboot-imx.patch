diff --git a/arch/arm/cpu/armv7/mx6/soc.c b/arch/arm/cpu/armv7/mx6/soc.c
index 3c3d2fd..c253168 100644
--- a/arch/arm/cpu/armv7/mx6/soc.c
+++ b/arch/arm/cpu/armv7/mx6/soc.c
@@ -57,6 +57,16 @@ struct scu_regs {
 
 static unsigned int fuse = ~0;
 
+/* Chris added debug function */
+void via_debug (int nIndex, int bOnOff);
+
+/* 1: cpu is mx6dl; 0: cpu is not mx6dl */
+int cpu_is_mx6dl(void) {
+	u32 sCpuType = readl(ANATOP_BASE_ADDR + 0x260);
+	return ((sCpuType >> 16) == 0x63) ? 0: 1;
+}
+/* End debug function */
+
 u32 get_cpu_rev(void)
 {
 	struct mxc_ccm_reg *ccm_regs = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
diff --git a/board/via/mx6qsm8q60/Makefile b/board/via/mx6qsm8q60/Makefile
new file mode 100644
index 0000000..254d3b9
--- /dev/null
+++ b/board/via/mx6qsm8q60/Makefile
@@ -0,0 +1,13 @@
+#
+# Copyright (C) 2007, Guennadi Liakhovetski <lg@denx.de>
+#
+# (C) Copyright 2011 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mx6qsm8q60.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff --git a/board/via/mx6qsm8q60/mx6qsm8q60.c b/board/via/mx6qsm8q60/mx6qsm8q60.c
new file mode 100644
index 0000000..bc9a46b
--- /dev/null
+++ b/board/via/mx6qsm8q60/mx6qsm8q60.c
@@ -0,0 +1,1297 @@
+/*
+ * Copyright (C) 2012-2014 Freescale Semiconductor, Inc.
+ *
+ * Author: Fabio Estevam <fabio.estevam@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <micrel.h>
+
+#if defined(CONFIG_MX6DL) && defined(CONFIG_MXC_EPDC)
+#include <lcd.h>
+#include <mxc_epdc_fb.h>
+#endif
+#include <asm/arch/mxc_hdmi.h>
+#include <asm/arch/crm_regs.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/io.h>
+#include <asm/arch/sys_proto.h>
+#ifdef CONFIG_SYS_I2C_MXC
+#include <i2c.h>
+#include <asm/imx-common/mxc_i2c.h>
+#endif
+#ifdef CONFIG_CMD_SATA
+#include <asm/imx-common/sata.h>
+#endif
+#ifdef CONFIG_FASTBOOT
+#include <fastboot.h>
+#ifdef CONFIG_ANDROID_RECOVERY
+#include <recovery.h>
+#endif
+#endif /*CONFIG_FASTBOOT*/
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS | PAD_CTL_SPEED_MED | \
+		      PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+/* Chris Added */
+int cpu_is_mx6dl(void);
+
+#ifdef CONFIG_SYS_I2C_MXC
+
+struct i2c_pads_info i2c_pad_info0[] = {{
+	.scl = {
+		.i2c_mode = MX6Q_PAD_CSI0_DAT9__I2C1_SCL	| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6Q_PAD_CSI0_DAT9__GPIO5_IO27	| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(5, 27)
+	},
+	.sda = {
+		.i2c_mode = MX6Q_PAD_CSI0_DAT8__I2C1_SDA	| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6Q_PAD_CSI0_DAT8__GPIO5_IO26	| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(5, 26)
+	}
+},{
+	.scl = {
+		.i2c_mode = MX6DL_PAD_CSI0_DAT9__I2C1_SCL	| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6DL_PAD_CSI0_DAT9__GPIO5_IO27| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(5, 27)
+	},
+	.sda = {
+		.i2c_mode = MX6DL_PAD_CSI0_DAT8__I2C1_SDA	| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6DL_PAD_CSI0_DAT8__GPIO5_IO26| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(5, 26)
+	}
+}};
+
+struct i2c_pads_info i2c_pad_info1[] = {{
+	.scl = {
+		.i2c_mode = MX6Q_PAD_KEY_COL3__I2C2_SCL		| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6Q_PAD_KEY_COL3__GPIO4_IO12	| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(4, 12)
+	},
+	.sda = {
+		.i2c_mode = MX6Q_PAD_KEY_ROW3__I2C2_SDA		| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6Q_PAD_KEY_ROW3__GPIO4_IO13	| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(4, 13)
+	}
+},{
+	.scl = {
+		.i2c_mode = MX6DL_PAD_KEY_COL3__I2C2_SCL	| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6DL_PAD_KEY_COL3__GPIO4_IO12	| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(4, 12)
+	},
+	.sda = {
+		.i2c_mode = MX6DL_PAD_KEY_ROW3__I2C2_SDA	| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6DL_PAD_KEY_ROW3__GPIO4_IO13	| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(4, 13)
+	}
+}};
+
+struct i2c_pads_info i2c_pad_info2[] = {{
+	.scl = {
+		.i2c_mode = MX6Q_PAD_GPIO_3__I2C3_SCL		| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6Q_PAD_GPIO_3__GPIO1_IO03	| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(1, 3)
+	},
+	.sda = {
+		.i2c_mode = MX6Q_PAD_GPIO_6__I2C3_SDA		| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6Q_PAD_GPIO_6__GPIO1_IO06	| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(1, 6)
+	}
+},{
+	.scl = {
+		.i2c_mode = MX6DL_PAD_GPIO_3__I2C3_SCL		| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6DL_PAD_GPIO_3__GPIO1_IO03	| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(1, 3)
+	},
+	.sda = {
+		.i2c_mode = MX6DL_PAD_GPIO_6__I2C3_SDA		| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX6DL_PAD_GPIO_6__GPIO1_IO06	| MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(1, 6)
+	}
+}};
+#endif
+
+#define HW_ANADIG_PLL_SYS	(0x00000000)
+#define HW_ANADIG_PLL_SYS_SET	(0x00000004)
+#define HW_ANADIG_PLL_SYS_CLR	(0x00000008)
+#define HW_ANADIG_PLL_528	(0x00000030)
+#define HW_ANADIG_PLL_528_SET	(0x00000034)
+#define HW_ANADIG_PLL_528_CLR	(0x00000038)
+
+#define REG_RD(base, reg) \
+	(*(volatile unsigned int *)((base) + (reg)))
+#define REG_WR(base, reg, value) \
+	((*(volatile unsigned int *)((base) + (reg))) = (value))
+#define REG_SET(base, reg, value) \
+	((*(volatile unsigned int *)((base) + (reg ## _SET))) = (value))
+#define REG_CLR(base, reg, value) \
+	((*(volatile unsigned int *)((base) + (reg ## _CLR))) = (value))
+
+enum {
+	CPU_CLK = 0,
+	PERIPH_CLK,
+	AHB_CLK,
+	IPG_CLK,
+	IPG_PERCLK,
+	UART_CLK,
+	CSPI_CLK,
+	DDR_CLK,
+	NFC_CLK,
+	ALL_CLK,
+};
+
+enum pll_clocks {
+	CPU_PLL1,	/* System PLL */
+	BUS_PLL2,	/* System Bus PLL */
+	USBOTG_PLL3,	/* OTG USB PLL */
+	AUD_PLL4,	/* Audio PLL */
+	VID_PLL5,	/* Video PLL */
+#ifndef CONFIG_MX6SL
+	MLB_PLL6,	/* MLB PLL */
+	USBHOST_PLL7,	/* Host USB PLL */
+#endif
+	ENET_PLL8,	/* ENET PLL */
+};
+
+#define PLL1_FREQ_MAX	1300000000
+#define PLL1_FREQ_MIN	650000000
+#define PLL2_FREQ_MAX	528000000
+#define PLL2_FREQ_MIN	480000000
+#define SZ_DEC_1M	1000000
+#define CONFIG_MX6_HCLK_FREQ	24000000
+#define CONFIG_REF_CLK_FREQ	24000000
+#define CLKCTL_CCSR	0x0C
+#define GPIO_PSR	0x08
+
+/*!
+ * This is to calculate divider based on reference clock and
+ * targeted clock based on the equation for each PLL.
+ *
+ * @param pll		pll number
+ * @param ref		reference clock freq in Hz
+ * @param target	targeted clock in Hz
+ *
+ * @return		divider if successful; -1 otherwise.
+ */
+
+static int calc_pll_divider(enum pll_clocks pll, u32 ref, u32 target)
+{
+	int i, div;
+
+	switch (pll) {
+		case CPU_PLL1:
+			if(target < PLL1_FREQ_MIN || target > PLL1_FREQ_MAX){
+				printf("PLL1 frequency should be"
+				"within [%d - %d] MHz \n", PLL1_FREQ_MIN / SZ_DEC_1M,
+					PLL1_FREQ_MAX / SZ_DEC_1M);
+				return -1;
+			}
+			for(i = 51, div = i; i < 109; i++){
+				if((ref * (i >> 1)) > target)
+					break;
+				div = i;
+			}
+			break;
+		case BUS_PLL2:
+			if(target < PLL2_FREQ_MIN || target > PLL2_FREQ_MAX){
+				printf("PLL2 frequency should be"
+				"within [%d - %d] MHz\n", PLL2_FREQ_MIN / SZ_DEC_1M,
+					PLL2_FREQ_MAX / SZ_DEC_1M);
+				return -1;
+			}
+			for(i = 0, div = i; i< 2; i++){
+				if(ref * (20 + (i << 1)) > target)
+					break;
+				div = i;
+			}
+		default:
+			printf("Changing this PLL not supported\n");
+			return -1;
+			break;
+	}
+	return div;
+}
+
+static int config_pll_clk(enum pll_clocks pll, u32 divider)
+{
+	u32 ccsr = readl(CCM_BASE_ADDR + CLKCTL_CCSR);
+
+	switch (pll){
+		case CPU_PLL1:
+			/* Switch ARM to PLL2 clock */
+			writel(ccsr | 0x4, CCM_BASE_ADDR + CLKCTL_CCSR);
+
+			REG_CLR(ANATOP_BASE_ADDR, HW_ANADIG_PLL_SYS,
+				BM_ANADIG_PLL_SYS_DIV_SELECT);
+			REG_SET(ANATOP_BASE_ADDR, HW_ANADIG_PLL_SYS,
+				BF_ANADIG_PLL_SYS_DIV_SELECT(divider));
+			/* Enable CPU PLL1 */
+			REG_SET(ANATOP_BASE_ADDR, HW_ANADIG_PLL_SYS,
+				BM_ANADIG_PLL_SYS_ENABLE);
+			/* Wait for PLL lock */
+			while(REG_RD(ANATOP_BASE_ADDR, HW_ANADIG_PLL_SYS) &
+				BM_ANADIG_PLL_SYS_LOCK)
+				udelay(10);
+			/* Clear bypass bit */
+			REG_CLR(ANATOP_BASE_ADDR, HW_ANADIG_PLL_SYS,
+				BM_ANADIG_PLL_SYS_BYPASS);
+
+			/* Switch back */
+			writel(ccsr & ~0x4, CCM_BASE_ADDR + CLKCTL_CCSR);
+			break;
+
+		case BUS_PLL2:
+			/* Switch to pll2 bypass clock */
+			writel(ccsr | 0x2, CCM_BASE_ADDR + CLKCTL_CCSR);
+
+			REG_CLR(ANATOP_BASE_ADDR, HW_ANADIG_PLL_528,
+                                BM_ANADIG_PLL_528_DIV_SELECT);
+                        REG_SET(ANATOP_BASE_ADDR, HW_ANADIG_PLL_528,
+                                divider);
+                        /* Enable CPU PLL2 */
+                        REG_SET(ANATOP_BASE_ADDR, HW_ANADIG_PLL_528,
+                                BM_ANADIG_PLL_528_ENABLE);
+                        /* Wait for PLL lock */
+                        while(REG_RD(ANATOP_BASE_ADDR, HW_ANADIG_PLL_528) &
+                                BM_ANADIG_PLL_528_LOCK)
+                                udelay(10);
+                        /* Clear bypass bit */
+                        REG_CLR(ANATOP_BASE_ADDR, HW_ANADIG_PLL_528,
+                                BM_ANADIG_PLL_528_BYPASS);
+        
+                        /* Switch back */
+                        writel(ccsr & ~0x2, CCM_BASE_ADDR + CLKCTL_CCSR);
+                        break;
+		default:
+			return -1;
+	}
+	return 0;
+}
+
+static int config_core_clk(u32 ref, u32 freq)
+{
+	int div = calc_pll_divider(CPU_PLL1, ref, freq);
+	if(div < 0){
+		printf("Can't find pll parameters\n");
+		return div;
+	}
+	return config_pll_clk(CPU_PLL1, div);
+}
+
+/*!
+ * This function assumes the expected core clock has to be changed by
+ * modifying the PLL. This is NOT true always but for most of the times,
+ * it is. So ti assumes the PLL output freq is the same as the expected
+ * core clock (arm_podf=0) unless the core clock is less than PLL_FREQ_MIN.
+ *
+ * @param ref		Pll input reference clock (24MHz)
+ * @param freq		targeted freq in Hz
+ * @param clk_type	clock type, e.g CPU_CLK, DDR_CLK, etc.
+ * @return		0 if successful; non-zero therwise
+ */
+
+int clk_config(u32 ref, u32 freq, u32 clk_type)
+{
+	freq *= SZ_DEC_1M;
+
+	switch(clk_type){
+		case CPU_CLK:
+			if(config_core_clk(ref, freq))
+				return -1;
+			break;
+/* Chris Added: CPU_CLK only*/
+/*		case PERIPH_CLK:
+			if(config_periph_clk(ref, freq))
+				return -1;
+			break;
+		case DDR_CLK:
+			if(config_ddr_clk(freq))
+				return -1;
+			break;
+		case NFC_CLK:
+			if(config_nfc_clk(freq))
+				return -1;
+			break;*/
+		default:
+			printf("Unsupported or invalid clock type! : (\n)");
+			return -1;
+	}
+	return 0;
+}
+
+int dram_init(void)
+{
+	//gd->ram_size = ((ulong)CONFIG_DDR_MB * 1024 * 1024);
+	/* Chris Added */
+	ulong nRamSize = (1u * 1024 * 1024 * 1024);
+	u32 reg = readl(GPIO6_BASE_ADDR + GPIO_PSR);
+	/* GPIO6_IO09 & GPIO6_IO10 for RAM size*/
+
+	switch(reg & 0x600) {
+		case 0x200:
+			/* 3.75GB */
+			nRamSize = (3840u * 1024 * 1024) - 4096;
+			/* 3.5GB */
+			//nRamSize = (3584u * 1024 * 1024);
+			break;
+		case 0x400:
+			nRamSize = (2u * 1024 * 1024 * 1024);
+			break;
+		default:	/* 0x600 for 1G */
+			nRamSize = (1u * 1024 * 1024 * 1024);
+			break;
+	}
+		
+	gd->ram_size = nRamSize;
+	return 0;
+}
+
+/* Chris Added */
+static void setup_iomux_uart(void)
+{
+	iomux_v3_cfg_t const mx6_pads[][4] = {{
+		MX6Q_PAD_EIM_D26__UART2_TX_DATA		| MUX_PAD_CTRL(UART_PAD_CTRL),
+		MX6Q_PAD_EIM_D27__UART2_RX_DATA		| MUX_PAD_CTRL(UART_PAD_CTRL),
+	},{
+		MX6DL_PAD_EIM_D26__UART2_TX_DATA	| MUX_PAD_CTRL(UART_PAD_CTRL),
+		MX6DL_PAD_EIM_D27__UART2_RX_DATA	| MUX_PAD_CTRL(UART_PAD_CTRL),
+	},};
+	
+	imx_iomux_v3_setup_multiple_pads(mx6_pads[cpu_is_mx6dl()], ARRAY_SIZE(mx6_pads[0]));
+}
+
+iomux_v3_cfg_t const mx6_enet_pads[][16] = {{
+	MX6Q_PAD_ENET_MDIO__ENET_MDIO		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6Q_PAD_ENET_MDC__ENET_MDC			| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6Q_PAD_RGMII_TXC__RGMII_TXC		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6Q_PAD_RGMII_TD0__RGMII_TD0		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6Q_PAD_RGMII_TD1__RGMII_TD1		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6Q_PAD_RGMII_TD2__RGMII_TD2		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6Q_PAD_RGMII_TD3__RGMII_TD3		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6Q_PAD_RGMII_TX_CTL__RGMII_TX_CTL	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6Q_PAD_ENET_REF_CLK__ENET_TX_CLK	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6Q_PAD_RGMII_RXC__RGMII_RXC		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6Q_PAD_RGMII_RD0__RGMII_RD0		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6Q_PAD_RGMII_RD1__RGMII_RD1		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6Q_PAD_RGMII_RD2__RGMII_RD2		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6Q_PAD_RGMII_RD3__RGMII_RD3		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6Q_PAD_RGMII_RX_CTL__RGMII_RX_CTL	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	/* AR8031 PHY Reset */
+	MX6Q_PAD_ENET_CRS_DV__GPIO1_IO25	| MUX_PAD_CTRL(NO_PAD_CTRL),
+},{
+	MX6DL_PAD_ENET_MDIO__ENET_MDIO		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6DL_PAD_ENET_MDC__ENET_MDC		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6DL_PAD_RGMII_TXC__RGMII_TXC		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6DL_PAD_RGMII_TD0__RGMII_TD0		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6DL_PAD_RGMII_TD1__RGMII_TD1		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6DL_PAD_RGMII_TD2__RGMII_TD2		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6DL_PAD_RGMII_TD3__RGMII_TD3		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6DL_PAD_RGMII_TX_CTL__RGMII_TX_CTL	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6DL_PAD_ENET_REF_CLK__ENET_TX_CLK	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6DL_PAD_RGMII_RXC__RGMII_RXC		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6DL_PAD_RGMII_RD0__RGMII_RD0		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6DL_PAD_RGMII_RD1__RGMII_RD1		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6DL_PAD_RGMII_RD2__RGMII_RD2		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6DL_PAD_RGMII_RD3__RGMII_RD3		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6DL_PAD_RGMII_RX_CTL__RGMII_RX_CTL	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	/* AR8031 PHY Reset */
+	MX6DL_PAD_ENET_CRS_DV__GPIO1_IO25	| MUX_PAD_CTRL(NO_PAD_CTRL),
+},};
+
+static void setup_iomux_enet(void)
+{
+	imx_iomux_v3_setup_multiple_pads(mx6_enet_pads[cpu_is_mx6dl()], ARRAY_SIZE(mx6_enet_pads[0]));
+
+	/* Reset AR8031 PHY */
+	gpio_direction_output(IMX_GPIO_NR(1, 25) , 0);
+	udelay(500);
+	gpio_set_value(IMX_GPIO_NR(1, 25), 1);
+}
+
+iomux_v3_cfg_t const mx6_usdhc2_pads[][7] = {{
+	MX6Q_PAD_SD2_CLK__SD2_CLK	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6Q_PAD_SD2_CMD__SD2_CMD	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6Q_PAD_SD2_DAT0__SD2_DATA0	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6Q_PAD_SD2_DAT1__SD2_DATA1	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6Q_PAD_SD2_DAT2__SD2_DATA2	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6Q_PAD_SD2_DAT3__SD2_DATA3	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6Q_PAD_GPIO_4__GPIO1_IO04	| MUX_PAD_CTRL(NO_PAD_CTRL), /* CD */
+//	MX6Q_PAD_GPIO_4__SD2_CD_B	| MUX_PAD_CTRL(NO_PAD_CTRL),
+},{
+	MX6DL_PAD_SD2_CLK__SD2_CLK	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6DL_PAD_SD2_CMD__SD2_CMD	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6DL_PAD_SD2_DAT0__SD2_DATA0	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6DL_PAD_SD2_DAT1__SD2_DATA1	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6DL_PAD_SD2_DAT2__SD2_DATA2	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6DL_PAD_SD2_DAT3__SD2_DATA3	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6DL_PAD_GPIO_4__GPIO1_IO04	| MUX_PAD_CTRL(NO_PAD_CTRL), /* CD */
+//	MX6DL_PAD_GPIO_4__SD2_CD_B	| MUX_PAD_CTRL(NO_PAD_CTRL),
+},};
+
+iomux_v3_cfg_t const mx6_usdhc4_pads[][10] = {{
+	MX6Q_PAD_SD4_CLK__SD4_CLK	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6Q_PAD_SD4_CMD__SD4_CMD	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6Q_PAD_SD4_DAT0__SD4_DATA0	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6Q_PAD_SD4_DAT1__SD4_DATA1	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6Q_PAD_SD4_DAT2__SD4_DATA2	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6Q_PAD_SD4_DAT3__SD4_DATA3	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6Q_PAD_SD4_DAT4__SD4_DATA4	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6Q_PAD_SD4_DAT5__SD4_DATA5	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6Q_PAD_SD4_DAT6__SD4_DATA6	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6Q_PAD_SD4_DAT7__SD4_DATA7	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+},{
+	MX6DL_PAD_SD4_CLK__SD4_CLK	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6DL_PAD_SD4_CMD__SD4_CMD	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6DL_PAD_SD4_DAT0__SD4_DATA0	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6DL_PAD_SD4_DAT1__SD4_DATA1	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6DL_PAD_SD4_DAT2__SD4_DATA2	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6DL_PAD_SD4_DAT3__SD4_DATA3	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6DL_PAD_SD4_DAT4__SD4_DATA4	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6DL_PAD_SD4_DAT5__SD4_DATA5	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6DL_PAD_SD4_DAT6__SD4_DATA6	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6DL_PAD_SD4_DAT7__SD4_DATA7	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
+},};
+
+iomux_v3_cfg_t const mx6_ecspi1_pads[][4] = {{
+	MX6Q_PAD_EIM_D16__ECSPI1_SCLK	| MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6Q_PAD_EIM_D17__ECSPI1_MISO	| MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6Q_PAD_EIM_D18__ECSPI1_MOSI	| MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6Q_PAD_EIM_D19__GPIO3_IO19	| MUX_PAD_CTRL(NO_PAD_CTRL),
+},{
+	MX6DL_PAD_EIM_D16__ECSPI1_SCLK	| MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6DL_PAD_EIM_D17__ECSPI1_MISO	| MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6DL_PAD_EIM_D18__ECSPI1_MOSI	| MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6DL_PAD_EIM_D19__GPIO3_IO19	| MUX_PAD_CTRL(NO_PAD_CTRL),
+},};
+
+static void setup_spinor(void)
+{
+	imx_iomux_v3_setup_multiple_pads(mx6_ecspi1_pads[cpu_is_mx6dl()], ARRAY_SIZE(mx6_ecspi1_pads[0]));
+
+	/* Chris Marked: CONFIG_SF_DEFAULT_CS = GPIO3_19 */
+	//gpio_direction_output(IMX_GPIO_NR(4, 9), 0);
+	gpio_direction_output(CONFIG_SF_DEFAULT_CS, 1);
+}
+
+iomux_v3_cfg_t const pcie_pads[][2] = {{
+	MX6Q_PAD_EIM_D19__GPIO3_IO19	| MUX_PAD_CTRL(NO_PAD_CTRL),	/* POWER */
+	MX6Q_PAD_GPIO_17__GPIO7_IO12	| MUX_PAD_CTRL(NO_PAD_CTRL),	/* RESET */
+},{
+	MX6DL_PAD_EIM_D19__GPIO3_IO19	| MUX_PAD_CTRL(NO_PAD_CTRL),	/* POWER */
+	MX6DL_PAD_GPIO_17__GPIO7_IO12	| MUX_PAD_CTRL(NO_PAD_CTRL),	/* RESET */
+}};
+
+static void setup_pcie(void)
+{
+	imx_iomux_v3_setup_multiple_pads(pcie_pads[cpu_is_mx6dl()], ARRAY_SIZE(pcie_pads[0]));
+}
+
+iomux_v3_cfg_t const di0_pads[][3] = {{
+	MX6Q_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK,	/* DISP0_CLK */
+	MX6Q_PAD_DI0_PIN2__IPU1_DI0_PIN02,		/* DISP0_HSYNC */
+	MX6Q_PAD_DI0_PIN3__IPU1_DI0_PIN03,		/* DISP0_VSYNC */
+},{
+	MX6DL_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK,	/* DISP0_CLK */
+	MX6DL_PAD_DI0_PIN2__IPU1_DI0_PIN02,		/* DISP0_HSYNC */
+	MX6DL_PAD_DI0_PIN3__IPU1_DI0_PIN03,		/* DISP0_VSYNC */
+}};
+
+#ifdef CONFIG_SYS_I2C_MXC
+#ifdef CONFIG_LDO_BYPASS_CHECK
+void ldo_mode_set(int ldo_bypass)
+{
+	/* Chris Added: no pmic */
+}
+#endif
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg usdhc_cfg[2] = {
+	{USDHC2_BASE_ADDR},
+	{USDHC4_BASE_ADDR},
+};
+
+int mmc_get_env_devno(void)
+{
+	u32 soc_sbmr = readl(SRC_BASE_ADDR + 0x4);
+	u32 dev_no;
+	u32 bootsel;
+
+	bootsel = (soc_sbmr & 0x000000FF) >> 6 ;
+
+	/* If not boot from sd/mmc, use default value */
+	if (bootsel != 1)
+		return CONFIG_SYS_MMC_ENV_DEV;
+
+	/* BOOT_CFG2[3] and BOOT_CFG2[4] */
+	dev_no = (soc_sbmr & 0x00001800) >> 11;
+
+	/* Chris Added: emmc = sd4, microsd = sd2(default) */
+	switch (dev_no) {
+		case 3: return 1;
+		default: return 0;
+	}
+	return dev_no;
+}
+
+int mmc_map_to_kernel_blk(int dev_no)
+{
+	return dev_no + 1;
+}
+
+#define USDHC2_CD_GPIO	IMX_GPIO_NR(1, 4)
+#define USDHC3_CD_GPIO	IMX_GPIO_NR(2, 0)
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC2_BASE_ADDR:
+		ret = !gpio_get_value(USDHC2_CD_GPIO);
+		break;
+	/* Chris Marked: no usdhc3 */
+	/*case USDHC3_BASE_ADDR:
+		ret = !gpio_get_value(USDHC3_CD_GPIO);
+		break;*/
+	case USDHC4_BASE_ADDR:
+		ret = 1; /* eMMC/uSDHC4 is always present */
+		break;
+	}
+
+	return ret;
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	s32 status = 0;
+	int i;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    SD2
+	 * mmc1                    SD3 //Chris Added: no sd3
+	 * mmc2                    eMMC
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			imx_iomux_v3_setup_multiple_pads(
+				mx6_usdhc2_pads[cpu_is_mx6dl()], ARRAY_SIZE(mx6_usdhc2_pads[0]));
+			gpio_direction_input(USDHC2_CD_GPIO);
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+			/* Chris Added: sd2 = 4bit */
+			usdhc_cfg[0].max_bus_width = 4;
+			break;
+/* Chris Marked: no sd3 */
+#if 0
+		case 1:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc3_pads, ARRAY_SIZE(usdhc3_pads));
+			gpio_direction_input(USDHC3_CD_GPIO);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+			break;
+#endif
+		case 1:
+			imx_iomux_v3_setup_multiple_pads(
+				mx6_usdhc4_pads[cpu_is_mx6dl()], ARRAY_SIZE(mx6_usdhc4_pads[0]));
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC4_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers"
+			       "(%d) then supported by the board (%d)\n",
+			       i + 1, CONFIG_SYS_FSL_USDHC_NUM);
+			return status;
+		}
+
+		status |= fsl_esdhc_initialize(bis, &usdhc_cfg[i]);
+	}
+
+	return status;
+}
+
+int check_mmc_autodetect(void)
+{
+	char *autodetect_str = getenv("mmcautodetect");
+
+	if ((autodetect_str != NULL) &&
+		(strcmp(autodetect_str, "yes") == 0)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+void board_late_mmc_env_init(void)
+{
+	char cmd[32];
+	char mmcblk[32];
+	u32 dev_no = mmc_get_env_devno();
+
+	if (!check_mmc_autodetect())
+		return;
+
+	setenv_ulong("mmcdev", dev_no);
+
+	/* Set mmcblk env */
+	sprintf(mmcblk, "/dev/mmcblk%dp2 rootwait rw",
+		mmc_map_to_kernel_blk(dev_no));
+	setenv("mmcroot", mmcblk);
+
+	sprintf(cmd, "mmc dev %d", dev_no);
+	run_command(cmd, 0);
+}
+#endif
+
+#if defined(CONFIG_MX6DL) && defined(CONFIG_MXC_EPDC)
+#ifdef CONFIG_SPLASH_SCREEN
+extern int mmc_get_env_devno(void);
+int setup_splash_img(void)
+{
+#ifdef CONFIG_SPLASH_IS_IN_MMC
+	int mmc_dev = mmc_get_env_devno();
+	ulong offset = CONFIG_SPLASH_IMG_OFFSET;
+	ulong size = CONFIG_SPLASH_IMG_SIZE;
+	ulong addr = 0;
+	char *s = NULL;
+	struct mmc *mmc = find_mmc_device(mmc_dev);
+	uint blk_start, blk_cnt, n;
+
+	s = getenv("splashimage");
+
+	if (NULL == s) {
+		puts("env splashimage not found!\n");
+		return -1;
+	}
+	addr = simple_strtoul(s, NULL, 16);
+
+	if (!mmc) {
+		printf("MMC Device %d not found\n", mmc_dev);
+		return -1;
+	}
+
+	if (mmc_init(mmc)) {
+		puts("MMC init failed\n");
+		return -1;
+	}
+
+	blk_start = ALIGN(offset, mmc->read_bl_len) / mmc->read_bl_len;
+	blk_cnt   = ALIGN(size, mmc->read_bl_len) / mmc->read_bl_len;
+	n = mmc->block_dev.block_read(mmc_dev, blk_start,
+					blk_cnt, (u_char *)addr);
+	flush_cache((ulong)addr, blk_cnt * mmc->read_bl_len);
+
+	return (n == blk_cnt) ? 0 : -1;
+#endif
+
+	return 0;
+}
+#endif
+
+int setup_waveform_file(void)
+{
+#ifdef CONFIG_WAVEFORM_FILE_IN_MMC
+	int mmc_dev = mmc_get_env_devno();
+	ulong offset = CONFIG_WAVEFORM_FILE_OFFSET;
+	ulong size = CONFIG_WAVEFORM_FILE_SIZE;
+	ulong addr = CONFIG_WAVEFORM_BUF_ADDR;
+	struct mmc *mmc = find_mmc_device(mmc_dev);
+	uint blk_start, blk_cnt, n;
+
+	if (!mmc) {
+		printf("MMC Device %d not found\n", mmc_dev);
+		return -1;
+	}
+
+	if (mmc_init(mmc)) {
+		puts("MMC init failed\n");
+		return -1;
+	}
+
+	blk_start = ALIGN(offset, mmc->read_bl_len) / mmc->read_bl_len;
+	blk_cnt   = ALIGN(size, mmc->read_bl_len) / mmc->read_bl_len;
+	n = mmc->block_dev.block_read(mmc_dev, blk_start,
+				      blk_cnt, (u_char *)addr);
+	flush_cache((ulong)addr, blk_cnt * mmc->read_bl_len);
+
+	return (n == blk_cnt) ? 0 : -1;
+#else
+	return -1;
+#endif
+}
+
+#endif
+
+int mx6_rgmii_rework(struct phy_device *phydev)
+{
+	phy_write(phydev, MDIO_DEVAD_NONE, MII_CTRL1000, 0x1c00);
+
+	/* control data pad skew - devaddr = 0x02, register = 0x04 */
+	ksz9031_phy_extended_write(phydev, 0x02,
+				   MII_KSZ9031_EXT_RGMII_CTRL_SIG_SKEW,
+				   MII_KSZ9031_MOD_DATA_NO_POST_INC, 0x0000);
+	/* rx data pad skew - devaddr = 0x02, register = 0x05 */
+	ksz9031_phy_extended_write(phydev, 0x02,
+				   MII_KSZ9031_EXT_RGMII_RX_DATA_SKEW,
+				   MII_KSZ9031_MOD_DATA_NO_POST_INC, 0x0000);
+	/* tx data pad skew - devaddr = 0x02, register = 0x05 */
+	ksz9031_phy_extended_write(phydev, 0x02,
+				   MII_KSZ9031_EXT_RGMII_TX_DATA_SKEW,
+				   MII_KSZ9031_MOD_DATA_NO_POST_INC, 0x0000);
+	/* gtx and rx clock pad skew - devaddr = 0x02, register = 0x08 */
+	ksz9031_phy_extended_write(phydev, 0x02,
+				   MII_KSZ9031_EXT_RGMII_CLOCK_SKEW,
+				   MII_KSZ9031_MOD_DATA_NO_POST_INC, 0x03FF);
+	return 0;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	mx6_rgmii_rework(phydev);
+#if 0
+	/* min rx data delay */
+	ksz9021_phy_extended_write(phydev,
+			MII_KSZ9021_EXT_RGMII_RX_DATA_SKEW, 0x0);
+	/* min tx data delay */
+	ksz9021_phy_extended_write(phydev,
+			MII_KSZ9021_EXT_RGMII_TX_DATA_SKEW, 0x0);
+	/* max rx/tx clock delay, min rx/tx control */
+	ksz9021_phy_extended_write(phydev,
+			MII_KSZ9021_EXT_RGMII_CLOCK_SKEW, 0xf0f0);
+#endif
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+
+#if defined(CONFIG_VIDEO_IPUV3)
+struct display_info_t {
+	int	bus;
+	int	addr;
+	int	pixfmt;
+	int	(*detect)(struct display_info_t const *dev);
+	void	(*enable)(struct display_info_t const *dev);
+	struct	fb_videomode mode;
+};
+
+static void disable_lvds(struct display_info_t const *dev)
+{
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+
+	int reg = readl(&iomux->gpr[2]);
+
+	reg &= ~(IOMUXC_GPR2_LVDS_CH0_MODE_MASK |
+		 IOMUXC_GPR2_LVDS_CH1_MODE_MASK);
+
+	writel(reg, &iomux->gpr[2]);
+}
+
+/* Chris Added */
+static int detect_hdmi(struct display_info_t const *dev)
+{
+	struct hdmi_regs *hdmi = (struct hdmi_regs *) HDMI_ARB_BASE_ADDR;
+	return readb(&hdmi->phy_stat0) & HDMI_DVI_STAT;
+}
+
+static void do_enable_hdmi(struct display_info_t const *dev)
+{
+	disable_lvds(dev);
+	imx_enable_hdmi_phy();
+}
+
+static struct display_info_t const displays[] = {{
+	.bus	= -1,
+	.addr	= 0,
+	.pixfmt	= IPU_PIX_FMT_RGB666,
+	.detect	= NULL,
+	.enable	= NULL,
+	.mode	= {
+		.name           = "Hannstar-XGA",
+		.refresh        = 60,
+		.xres           = 1024,
+		.yres           = 768,
+		.pixclock       = 15385,
+		.left_margin    = 220,
+		.right_margin   = 40,
+		.upper_margin   = 21,
+		.lower_margin   = 7,
+		.hsync_len      = 60,
+		.vsync_len      = 10,
+		.sync           = FB_SYNC_EXT,
+		.vmode          = FB_VMODE_NONINTERLACED
+} }, {
+	.bus	= -1,
+	.addr	= 0,
+	.pixfmt	= IPU_PIX_FMT_RGB24,
+	.detect	= NULL,
+	.enable	= do_enable_hdmi,
+	.mode	= {
+		.name           = "HDMI",
+		.refresh        = 60,
+		.xres           = 640,
+		.yres           = 480,
+		.pixclock       = 39721,
+		.left_margin    = 48,
+		.right_margin   = 16,
+		.upper_margin   = 33,
+		.lower_margin   = 10,
+		.hsync_len      = 96,
+		.vsync_len      = 2,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+
+int board_video_skip(void)
+{
+	int i;
+	int ret;
+	char const *panel = getenv("panel");
+	if (!panel) {
+		for (i = 0; i < ARRAY_SIZE(displays); i++) {
+			struct display_info_t const *dev = displays+i;
+			if (dev->detect && dev->detect(dev)) {
+				panel = dev->mode.name;
+				printf("auto-detected panel %s\n", panel);
+				break;
+			}
+		}
+		if (!panel) {
+			panel = displays[0].mode.name;
+			printf("No panel detected: default to %s\n", panel);
+			i = 0;
+		}
+	} else {
+		for (i = 0; i < ARRAY_SIZE(displays); i++) {
+			if (!strcmp(panel, displays[i].mode.name))
+				break;
+		}
+	}
+	if (i < ARRAY_SIZE(displays)) {
+		ret = ipuv3_fb_init(&displays[i].mode, 0,
+				    displays[i].pixfmt);
+		if (!ret) {
+			if (displays[i].enable)
+				displays[i].enable(displays+i);
+			printf("Display: %s (%ux%u)\n",
+			       displays[i].mode.name,
+			       displays[i].mode.xres,
+			       displays[i].mode.yres);
+		} else
+			printf("LCD %s cannot be configured: %d\n",
+			       displays[i].mode.name, ret);
+	} else {
+		printf("unsupported panel %s\n", panel);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void setup_display(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+	int reg;
+
+	/* Setup HSYNC, VSYNC, DISP_CLK for debugging purposes */
+	imx_iomux_v3_setup_multiple_pads(di0_pads[cpu_is_mx6dl()], ARRAY_SIZE(di0_pads[0]));
+
+	enable_ipu_clock();
+	imx_setup_hdmi();
+
+	/* Turn on LDB0, LDB1, IPU,IPU DI0 clocks */
+	reg = readl(&mxc_ccm->CCGR3);
+	reg |=  MXC_CCM_CCGR3_LDB_DI0_MASK | MXC_CCM_CCGR3_LDB_DI1_MASK;
+	writel(reg, &mxc_ccm->CCGR3);
+
+	/* set LDB0, LDB1 clk select to 011/011 */
+	reg = readl(&mxc_ccm->cs2cdr);
+	reg &= ~(MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_MASK
+		 | MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_MASK);
+	reg |= (3 << MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_OFFSET)
+	      | (3 << MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_OFFSET);
+	writel(reg, &mxc_ccm->cs2cdr);
+
+	reg = readl(&mxc_ccm->cscmr2);
+	reg |= MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV | MXC_CCM_CSCMR2_LDB_DI1_IPU_DIV;
+	writel(reg, &mxc_ccm->cscmr2);
+
+	reg = readl(&mxc_ccm->chsccdr);
+	reg |= (CHSCCDR_CLK_SEL_LDB_DI0
+		<< MXC_CCM_CHSCCDR_IPU1_DI0_CLK_SEL_OFFSET);
+	reg |= (CHSCCDR_CLK_SEL_LDB_DI0
+		<< MXC_CCM_CHSCCDR_IPU1_DI1_CLK_SEL_OFFSET);
+	writel(reg, &mxc_ccm->chsccdr);
+
+	reg = IOMUXC_GPR2_BGREF_RRMODE_EXTERNAL_RES
+	     | IOMUXC_GPR2_DI1_VS_POLARITY_ACTIVE_LOW
+	     | IOMUXC_GPR2_DI0_VS_POLARITY_ACTIVE_LOW
+	     | IOMUXC_GPR2_BIT_MAPPING_CH1_SPWG
+	     | IOMUXC_GPR2_DATA_WIDTH_CH1_18BIT
+	     | IOMUXC_GPR2_BIT_MAPPING_CH0_SPWG
+	     | IOMUXC_GPR2_DATA_WIDTH_CH0_18BIT
+	     | IOMUXC_GPR2_LVDS_CH0_MODE_DISABLED
+	     | IOMUXC_GPR2_LVDS_CH1_MODE_ENABLED_DI0;
+	writel(reg, &iomux->gpr[2]);
+
+	reg = readl(&iomux->gpr[3]);
+	reg = (reg & ~(IOMUXC_GPR3_LVDS1_MUX_CTL_MASK
+			| IOMUXC_GPR3_HDMI_MUX_CTL_MASK))
+	    | (IOMUXC_GPR3_MUX_SRC_IPU1_DI0
+	       << IOMUXC_GPR3_LVDS1_MUX_CTL_OFFSET);
+	writel(reg, &iomux->gpr[3]);
+}
+#endif /* CONFIG_VIDEO_IPUV3 */
+
+/*
+ * Do not overwrite the console
+ * Use always serial for U-Boot console
+ */
+int overwrite_console(void)
+{
+	return 1;
+}
+
+int board_eth_init(bd_t *bis)
+{
+	setup_iomux_enet();
+	setup_pcie();
+
+	return cpu_eth_init(bis);
+}
+
+int board_early_init_f(void)
+{
+	setup_iomux_uart();
+	/* Chris Added */
+	clk_config(CONFIG_REF_CLK_FREQ, 1000, CPU_CLK);
+#if defined(CONFIG_VIDEO_IPUV3)
+	setup_display();
+#endif
+
+	setup_spinor();
+
+#ifdef CONFIG_CMD_SATA
+	setup_sata();
+#endif
+
+	return 0;
+}
+
+int board_init(void)
+{
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+	return 0;
+}
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"sd2",	 MAKE_CFGVAL(0x40, 0x28, 0x00, 0x00)},
+	/* Chris Marked: no sd3 */
+	//{"sd3",	 MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	/* 8 bit bus width */
+	{"emmc", MAKE_CFGVAL(0x60, 0x58, 0x00, 0x00)},
+	{NULL,	 0},
+};
+#endif
+
+int board_late_init(void)
+{
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, i2c_pad_info0 + cpu_is_mx6dl());
+	setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, i2c_pad_info1 + cpu_is_mx6dl());
+	setup_i2c(2, CONFIG_SYS_I2C_SPEED, 0x7f, i2c_pad_info2 + cpu_is_mx6dl());
+#endif
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
+#endif
+
+	return 0;
+}
+
+int checkboard(void)
+{
+	printf("Board: %s-QSM-8Q60\n", cpu_is_mx6dl() ? "MX6DL" : "MX6Q");
+	return 0;
+}
+
+#ifdef CONFIG_FASTBOOT
+
+void board_fastboot_setup(void)
+{
+	switch (get_boot_device()) {
+#if defined(CONFIG_FASTBOOT_STORAGE_SATA)
+	case SATA_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "sata");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "booti sata");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_SATA*/
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD2_BOOT:
+	case MMC2_BOOT:
+	    if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc0");
+	    if (!getenv("bootcmd"))
+			setenv("bootcmd", "booti mmc0");
+	    break;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+	    if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc1");
+	    if (!getenv("bootcmd"))
+			setenv("bootcmd", "booti mmc1");
+	    break;
+	case MMC4_BOOT:
+	    if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc2");
+	    if (!getenv("bootcmd"))
+			setenv("bootcmd", "booti mmc2");
+	    break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+	default:
+		printf("unsupported boot devices\n");
+		break;
+	}
+
+}
+
+#ifdef CONFIG_ANDROID_RECOVERY
+
+#define GPIO_VOL_DN_KEY IMX_GPIO_NR(1, 5)
+iomux_v3_cfg_t const recovery_key_pads[][1] = {{
+	(MX6Q_PAD_GPIO_5__GPIO1_IO05 | MUX_PAD_CTRL(NO_PAD_CTRL)),
+},{
+	(MX6DL_PAD_GPIO_5__GPIO1_IO05 | MUX_PAD_CTRL(NO_PAD_CTRL)),
+}};
+
+int check_recovery_cmd_file(void)
+{
+    int button_pressed = 0;
+    int recovery_mode = 0;
+
+    recovery_mode = recovery_check_and_clean_flag();
+
+    /* Check Recovery Combo Button press or not. */
+	imx_iomux_v3_setup_multiple_pads(recovery_key_pads[cpu_is_mx6dl()],
+			ARRAY_SIZE(recovery_key_pads[0]));
+
+    gpio_direction_input(GPIO_VOL_DN_KEY);
+
+    if (gpio_get_value(GPIO_VOL_DN_KEY) == 0) { /* VOL_DN key is low assert */
+		button_pressed = 1;
+		printf("Recovery key pressed\n");
+    }
+
+    return recovery_mode || button_pressed;
+}
+
+void board_recovery_setup(void)
+{
+	int bootdev = get_boot_device();
+
+	switch (bootdev) {
+#if defined(CONFIG_FASTBOOT_STORAGE_SATA)
+	case SATA_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+				"booti sata recovery");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_SATA*/
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+				"booti mmc0 recovery");
+		break;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+				"booti mmc1 recovery");
+		break;
+	case MMC4_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+				"booti mmc2 recovery");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+	default:
+		printf("Unsupported bootup device for recovery: dev: %d\n",
+			bootdev);
+		return;
+	}
+
+	printf("setup env for recovery..\n");
+	setenv("bootcmd", "run bootcmd_android_recovery");
+}
+
+#endif /*CONFIG_ANDROID_RECOVERY*/
+
+#endif /*CONFIG_FASTBOOT*/
+
+/* Chris Added: no CONFIG_IMX_UDC */
+#ifdef CONFIG_IMX_UDC
+iomux_v3_cfg_t const mx6_otg_udc_pads[][1] = {{
+	(MX6Q_PAD_ENET_RX_ER__USB_OTG_ID | MUX_PAD_CTRL(NO_PAD_CTRL)),
+},{
+	(MX6DL_PAD_ENET_RX_ER__USB_OTG_ID | MUX_PAD_CTRL(NO_PAD_CTRL)),
+}};
+
+void udc_pins_setting(void)
+{
+	imx_iomux_v3_setup_multiple_pads(mx6_otg_udc_pads[cpu_is_mx6dl()],
+			ARRAY_SIZE(mx6_otg_udc_pads[0]));
+
+	/*set daisy chain for otg_pin_id on 6q. for 6dl, this bit is reserved*/
+	mxc_iomux_set_gpr_register(1, 13, 1, 0);
+}
+#endif /*CONFIG_IMX_UDC*/
+
+#ifdef CONFIG_USB_EHCI_MX6
+iomux_v3_cfg_t const mx6_usb_otg_pads[][2] = {{
+	MX6Q_PAD_EIM_D22__USB_OTG_PWR	| MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6Q_PAD_ENET_RX_ER__USB_OTG_ID	| MUX_PAD_CTRL(NO_PAD_CTRL),
+},{
+	MX6DL_PAD_EIM_D22__USB_OTG_PWR	| MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6DL_PAD_ENET_RX_ER__USB_OTG_ID| MUX_PAD_CTRL(NO_PAD_CTRL),
+}};
+
+iomux_v3_cfg_t const mx6_usb_hc1_pads[][1] = {{
+	MX6Q_PAD_EIM_DA0__GPIO3_IO00	| MUX_PAD_CTRL(NO_PAD_CTRL),
+},{
+	MX6DL_PAD_EIM_DA0__GPIO3_IO00	| MUX_PAD_CTRL(NO_PAD_CTRL),
+}};
+
+int board_ehci_hcd_init(int port)
+{
+	switch (port) {
+	case 0:
+		imx_iomux_v3_setup_multiple_pads(mx6_usb_otg_pads[cpu_is_mx6dl()],
+			ARRAY_SIZE(mx6_usb_otg_pads[0]));
+
+		/*set daisy chain for otg_pin_id on 6q. for 6dl, this bit is reserved*/
+		mxc_iomux_set_gpr_register(1, 13, 1, 0);
+		break;
+	case 1:
+		imx_iomux_v3_setup_multiple_pads(mx6_usb_hc1_pads[cpu_is_mx6dl()],
+			ARRAY_SIZE(mx6_usb_hc1_pads[0]));
+		/* Chris Added: Reset USB hub: USB_HUB_RESET_B=GPIO_18=GPIO7_IO13 */
+		gpio_direction_output(IMX_GPIO_NR(7, 13), 0);
+		mdelay(2);
+		gpio_set_value(IMX_GPIO_NR(7, 13), 1);
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return 1;
+	}
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	switch (port) {
+	case 0:
+		break;
+	case 1:
+		/* gpio_direction_output(IMX_GPIO_NR(1, 29), on ? 1 : 0); */
+		gpio_direction_output(IMX_GPIO_NR(7, 13), on ? 1 : 0);
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return 1;
+	}
+	return 0;
+}
+#endif
+
+/* Chris Added: add a command */
+static int cpu_detect(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	return cpu_is_mx6dl() ? 1 : 0;
+}
+
+U_BOOT_CMD(
+	cpudetect, CONFIG_SYS_MAXARGS, 0, cpu_detect,
+	"detect cpu type",
+	"Returns 0: iMX6Q, 1: iMX6DL"
+);
+
+
+
+#if defined(CONFIG_CMD_SAVEENV) && !defined(CONFIG_ENV_IS_NOWHERE)
+#include <environment.h>
+
+static int bDestroyEnv = 0;
+int in_destroyenv(void) {
+	return bDestroyEnv;
+}
+int do_destroyenv(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int nResult;
+
+	bDestroyEnv = 1;
+	/* printf("invalidate the CRC\n"); */
+	printf("write invalidate enviroment data to storage\n");
+	nResult = saveenv() ? 1 : 0;
+	bDestroyEnv = 0;
+	return nResult;
+}
+#endif
+
+#if defined(CONFIG_CMD_SAVEENV) && !defined(CONFIG_ENV_IS_NOWHERE)
+U_BOOT_CMD(
+	destroyenv, CONFIG_SYS_MAXARGS, 0, do_destroyenv,
+	"destroy enviroment variables stored in medium",
+	"\n	- destroy all environment variables in medium"
+	"\n	  after reset the default settings will be used"
+);
+#endif
+
+#include "viatools.c"
diff --git a/board/via/mx6qsm8q60/plugin.S b/board/via/mx6qsm8q60/plugin.S
new file mode 100644
index 0000000..7b27ba2
--- /dev/null
+++ b/board/via/mx6qsm8q60/plugin.S
@@ -0,0 +1,243 @@
+/*
+ * Copyright (C) 2012-2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* Chris Added: use old method */
+#define ROM_API_TABLE_BASE_ADDR_LEGACY		0xC0
+#define ROM_API_TABLE_BASE_ADDR_MX6DQ_TO15	0xC4
+#define ROM_API_TABLE_BASE_ADDR_MX6DL_TO12	0xC4
+#define ROM_API_HWCNFG_SETUP_OFFSET		0x08
+#define ROM_VERSION_OFFSET			0x48
+#define ROM_VERSION_TO12			0x12
+#define ROM_VERSION_TO15			0x15
+#define IRAM_FREE_START				0x00907000
+
+#define MXC_DCD_ITEM(i, addr, val)	\
+	ldr r1, =val;	\
+	ldr r0, =addr;	\
+	str r1, [r0];
+
+.macro qsm8q60_imx6_ddr_setting
+
+// CCM_BASE_addr = 0x020C4000
+//DDR clk
+	ldr r0, =0x020C8260
+	ldr r6, [r0]
+	lsr r6, r6, #16
+	and r6, r6, #0xff
+	cmp r6, #0x63
+	bne Label_mx6dl_speed
+// 528MHz
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0x00020324
+	str r1, [r0, #0x018]
+	b Label_mx6_speed_end
+Label_mx6dl_speed:
+// 400MHz
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0x00060324
+	str r1, [r0, #0x018]
+Label_mx6_speed_end:
+
+// qsm8q60 - RAM size check: GPIO6_IO09 & GPIO6_IO10
+// 0x200 - 4G; 0x400 - 2G; 0x600 - 1G
+	cmp r6, #0x63
+	bne Label_mx6dl_gpio
+	ldr r1, =0x05
+	ldr r0, =0x20e02dc
+	str r1, [r0]
+	ldr r0, =0x20e02e0
+	str r1, [r0]
+	b Label_mx6_gpio_end
+Label_mx6dl_gpio:
+	ldr r1, =0x05
+	ldr r0, =0x20e02a8
+	str r1, [r0]
+	ldr r0, =0x20e02a4
+	str r1, [r0]
+Label_mx6_gpio_end:
+	ldr r0, =0x20b0004
+	ldr r1, =0x00
+	str r1, [r0]
+	ldr r0, =0x20b0008
+	ldr r1, [r0]
+	and r1, #0x600
+	cmp r1, #0x200
+	beq Label_qsm8q60_4g_a
+	cmp r1, #0x400
+	beq Label_qsm8q60_2g
+	// default r1 = 3 = 1g
+	b Label_qsm8q60_1g
+Label_qsm8q60_4g_a:
+	b Label_qsm8q60_4g_b
+
+	.ltorg
+Label_qsm8q60_2g:
+	cmp r6, #0x63
+	bne Label_mx6dl_2g_ram
+// imx6q_2g_ram
+#include "qsm8q60_mx6q_2g.cfg"
+	b Label_mx6_2g_ram_end
+Label_mx6dl_2g_ram:
+// imx6dl_2g_ram
+#include "qsm8q60_mx6dl_2g.cfg"
+Label_mx6_2g_ram_end:
+	b Label_qsm8q60_ram_setting_end
+
+	.ltorg
+Label_qsm8q60_1g:
+	cmp r6, #0x63
+	bne Label_mx6dl_1g_ram
+// imx6q_1g_ram
+#include "qsm8q60_mx6q_1g.cfg"
+	b Label_mx6_1g_ram_end
+Label_mx6dl_1g_ram:
+// imx6dl_1g_ram
+#include "qsm8q60_mx6dl_1g.cfg"
+Label_mx6_1g_ram_end:
+	b Label_qsm8q60_ram_setting_end
+
+	.ltorg
+Label_qsm8q60_4g_b:
+#include "qsm8q60_mx6q_4g.cfg"
+
+
+Label_qsm8q60_ram_setting_end:
+
+.endm
+
+/* Chris: ref. ./include/asm/arch/mx6_plugin.S */
+
+.macro imx6_clock_gating
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0x00C03F3F
+	str r1, [r0, #0x068]
+	ldr r1, =0x0030FC03
+	str r1, [r0, #0x06c]
+	ldr r1, =0x0FFFC000
+	str r1, [r0, #0x070]
+	ldr r1, =0x3FF00000
+	str r1, [r0, #0x074]
+	ldr r1, =0x00FFF300
+	str r1, [r0, #0x078]
+	ldr r1, =0x0F0000C3
+	str r1, [r0, #0x07c]
+	ldr r1, =0x000003FF
+	str r1, [r0, #0x080]
+.endm
+
+.macro imx6_qos_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0xF00000CF
+	str r1, [r0, #0x10]
+
+	ldr r1, =0x007F007F
+	str r1, [r0, #0x18]
+	str r1, [r0, #0x1c]
+.endm
+
+/* Chris: ref. ./include/asm/arch/mx6_plugin.S */
+
+plugin_start:
+	push	{r0-r4, lr}
+	qsm8q60_imx6_ddr_setting
+	imx6_clock_gating
+	imx6_qos_setting
+
+/*
+ * The following is to fill in those arguments for this ROM function
+ * pu_irom_hwcnfg_setup(void **start, size_t *bytes, const void *boot_data)
+ * This function is used to copy data from the storage media into DDR.
+ * start - Initial (possibly partial) image load address on entry.
+ *         Final image load address on exit.
+ * bytes - Initial (possibly partial) image size on entry.
+ *         Final image size on exit.
+ * boot_data - Initial @ref ivt Boot Data load address.
+ */
+	adr r0, boot_data2
+	adr r1, image_len2
+	adr r2, boot_data2
+
+#ifdef CONFIG_SYS_BOOT_EIMNOR
+	ldr r3, =0x00900800
+	ldr r4, =0x08000000
+	str r4, [r3, #0xc0]
+#endif
+
+/*
+ * check the _pu_irom_api_table for the address
+ */
+before_calling_rom___pu_irom_hwcnfg_setup:
+// Chris: qsm8q60 method.
+// * r6 is set by qsm8q60_imx6_ddr_setting
+	ldr r3, =ROM_VERSION_OFFSET
+	ldr r4, [r3]
+	cmp r6, #0x63
+	bne Label_mx6dl_version
+	ldr r3, =ROM_VERSION_TO15
+	cmp r4,r3
+	ldrge r3, =ROM_API_TABLE_BASE_ADDR_MX6DQ_TO15
+	b Label_mx6_version_end
+Label_mx6dl_version:
+	ldr r3, =ROM_VERSION_TO12
+	cmp r4, r3
+	ldrge r3, =ROM_API_TABLE_BASE_ADDR_MX6DL_TO12
+Label_mx6_version_end:
+	ldrlt r3, =ROM_API_TABLE_BASE_ADDR_LEGACY
+	ldr r4, [r3, #ROM_API_HWCNFG_SETUP_OFFSET]
+	blx r4
+after_calling_rom___pu_irom_hwcnfg_setup:
+
+
+/* To return to ROM from plugin, we need to fill in these argument.
+ * Here is what need to do:
+ * Need to construct the paramters for this function before return to ROM:
+ * plugin_download(void **start, size_t *bytes, UINT32 *ivt_offset)
+ */
+	pop {r0-r4, lr}
+	ldr r5, boot_data2
+	str r5, [r0]
+	ldr r5, image_len2
+	str r5, [r1]
+	ldr r5, second_ivt_offset
+	str r5, [r2]
+	mov r0, #1
+
+	/* return back to ROM code */
+	bx lr
+
+/* make the following data right in the end of the output */
+.ltorg
+
+#ifdef CONFIG_SYS_BOOT_EIMNOR
+#define FLASH_OFFSET 0x1000
+#else
+#define FLASH_OFFSET 0x400
+#endif
+
+/*
+ * second_ivt_offset is the offset from the "second_ivt_header" to
+ * "image_copy_start", which involves FLASH_OFFSET, plus the first
+ * ivt_header, the plugin code size itself recorded by "ivt2_header"
+ */
+
+second_ivt_offset:	.long (ivt2_header + 0x2C + FLASH_OFFSET)
+
+/*
+ * The following is the second IVT header plus the second boot data
+ */
+ivt2_header:		.long 0x0
+app2_code_jump_v:	.long 0x0
+reserv3:		.long 0x0
+dcd2_ptr:		.long 0x0
+boot_data2_ptr:		.long 0x0
+self_ptr2:		.long 0x0
+app_code_csf2:		.long 0x0
+reserv4:		.long 0x0
+boot_data2:		.long 0x0
+image_len2:		.long 0x0
+plugin2:		.long 0x0
diff --git a/board/via/mx6qsm8q60/qsm8q60_dram.cfg b/board/via/mx6qsm8q60/qsm8q60_dram.cfg
new file mode 100644
index 0000000..8bb3ecd
--- /dev/null
+++ b/board/via/mx6qsm8q60/qsm8q60_dram.cfg
@@ -0,0 +1,164 @@
+/*
+ * Copyright (C) 2011-2014 Freescale Semiconductor, Inc.
+ * Jason Liu <r64343@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of spi, sd, sata
+ * the board has no nand and eimnor
+ * spinor: flash_offset: 0x0400
+ * sata:   flash_offset: 0x0400
+ * sd/mmc: flash_offset: 0x0400
+ */
+
+/* the same flash_offset as sd */
+BOOT_FROM      sd
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/via/mx6qsm8q60/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF 0x2000
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *      Addr-type register length (1,2 or 4 bytes)
+ *      Address   absolute address of the register
+ *      value     value to be stored in the register
+ */
+
+/* Chris: vab820 mx6q_1gb DRAM setting */
+DATA 4, 0x020e0798, 0x000C0000
+DATA 4, 0x020e0758, 0x00000000
+DATA 4, 0x020e0588, 0x00000028
+DATA 4, 0x020e0594, 0x00000028
+DATA 4, 0x020e056c, 0x00000028
+DATA 4, 0x020e0578, 0x00000028
+DATA 4, 0x020e074c, 0x00000028
+DATA 4, 0x020e057c, 0x00000028
+DATA 4, 0x020e058c, 0x00000000
+DATA 4, 0x020e059c, 0x00000028
+DATA 4, 0x020e05a0, 0x00000028
+DATA 4, 0x020e078c, 0x00000028
+DATA 4, 0x020e0750, 0x00020000
+DATA 4, 0x020e05a8, 0x00000028
+DATA 4, 0x020e05b0, 0x00000028
+DATA 4, 0x020e0524, 0x00000028
+DATA 4, 0x020e051c, 0x00000028
+DATA 4, 0x020e0518, 0x00000028
+DATA 4, 0x020e050c, 0x00000028
+DATA 4, 0x020e05b8, 0x00000028
+DATA 4, 0x020e05c0, 0x00000028
+DATA 4, 0x020e0774, 0x00020000
+DATA 4, 0x020e0784, 0x00000028
+DATA 4, 0x020e0788, 0x00000028
+DATA 4, 0x020e0794, 0x00000028
+DATA 4, 0x020e079c, 0x00000028
+DATA 4, 0x020e07a0, 0x00000028
+DATA 4, 0x020e07a4, 0x00000028
+DATA 4, 0x020e07a8, 0x00000028
+DATA 4, 0x020e0748, 0x00000028
+DATA 4, 0x020e05ac, 0x00000028
+DATA 4, 0x020e05b4, 0x00000028
+DATA 4, 0x020e0528, 0x00000028
+DATA 4, 0x020e0520, 0x00000028
+DATA 4, 0x020e0514, 0x00000028
+DATA 4, 0x020e0510, 0x00000028
+DATA 4, 0x020e05bc, 0x00000028
+DATA 4, 0x020e05c4, 0x00000028
+DATA 4, 0x021b0800, 0xA1380003
+DATA 4, 0x021b080c, 0x001C0013
+DATA 4, 0x021b0810, 0x0022001C
+DATA 4, 0x021b480c, 0x00160025
+DATA 4, 0x021b4810, 0x000C001C
+DATA 4, 0x021b083c, 0x03340348
+DATA 4, 0x021b0840, 0x0236032C
+DATA 4, 0x021b483c, 0x03340344
+DATA 4, 0x021b4840, 0x032C0300
+DATA 4, 0x021b0848, 0x32282E30
+DATA 4, 0x021b4848, 0x302A283A
+DATA 4, 0x021b0850, 0x3A363E38
+DATA 4, 0x021b4850, 0x40303E36
+DATA 4, 0x021b081c, 0x33333333
+DATA 4, 0x021b0820, 0x33333333
+DATA 4, 0x021b0824, 0x33333333
+DATA 4, 0x021b0828, 0x33333333
+DATA 4, 0x021b481c, 0x33333333
+DATA 4, 0x021b4820, 0x33333333
+DATA 4, 0x021b4824, 0x33333333
+DATA 4, 0x021b4828, 0x33333333
+DATA 4, 0x021b08b8, 0x00000800
+DATA 4, 0x021b48b8, 0x00000800
+DATA 4, 0x021b0004, 0x00020036
+DATA 4, 0x021b0008, 0x09444040
+DATA 4, 0x021b000c, 0x54597974
+DATA 4, 0x021b0010, 0xDB538F64
+DATA 4, 0x021b0014, 0x01FF00DB
+DATA 4, 0x021b0018, 0x00001740
+DATA 4, 0x021b001c, 0x00008000
+DATA 4, 0x021b002c, 0x000026D2
+DATA 4, 0x021b0030, 0x00591023
+DATA 4, 0x021b0040, 0x00000027
+DATA 4, 0x021b0000, 0x831A0000
+DATA 4, 0x021b001c, 0x02088032
+DATA 4, 0x021b001c, 0x00008033
+DATA 4, 0x021b001c, 0x00048031
+DATA 4, 0x021b001c, 0x09308030
+DATA 4, 0x021b001c, 0x04008040
+DATA 4, 0x021b0020, 0x00007800
+DATA 4, 0x021b0818, 0x00022227
+DATA 4, 0x021b4818, 0x00022227
+DATA 4, 0x021b0004, 0x00020036
+DATA 4, 0x021b0404, 0x00011006
+DATA 4, 0x021b001c, 0x00000000
+
+/* not edit */
+/* set the default clock gate to save power */
+DATA 4, 0x020c4068, 0x00C03F3F
+DATA 4, 0x020c406c, 0x0030FC03
+DATA 4, 0x020c4070, 0x0FFFC000
+DATA 4, 0x020c4074, 0x3FF00000
+DATA 4, 0x020c4078, 0x00FFF300
+DATA 4, 0x020c407c, 0x0F0000F3
+DATA 4, 0x020c4080, 0x000003FF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+
+DATA 4, 0x020e0010, 0xF00000CF
+
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+
+DATA 4, 0x020e0018, 0x007F007F
+DATA 4, 0x020e001c, 0x007F007F
+
+/*
+ * Setup CCM_CCOSR register as follows:
+ *
+ * cko1_en  = 1	   --> CKO1 enabled
+ * cko1_div = 111  --> divide by 8
+ * cko1_sel = 1011 --> ahb_clk_root
+ *
+ * This sets CKO1 at ahb_clk_root/8 = 132/8 = 16.5 MHz
+ */
+DATA 4, 0x020c4060, 0x000000fb
+#endif
diff --git a/board/via/mx6qsm8q60/qsm8q60_mx6dl_1g.cfg b/board/via/mx6qsm8q60/qsm8q60_mx6dl_1g.cfg
new file mode 100644
index 0000000..eec9fc6
--- /dev/null
+++ b/board/via/mx6qsm8q60/qsm8q60_mx6dl_1g.cfg
@@ -0,0 +1,121 @@
+
+
+// imx6dl_1g_ram
+# IOMUXC_BASE_ADDR  = 0x20e0000
+# DDR IO TYPE
+MXC_DCD_ITEM(1, IOMUXC_BASE_ADDR + 0x774, 0x000c0000)
+MXC_DCD_ITEM(2, IOMUXC_BASE_ADDR + 0x754, 0x00000000)
+# Clock
+MXC_DCD_ITEM(3, IOMUXC_BASE_ADDR + 0x4ac, 0x00000028)
+MXC_DCD_ITEM(4, IOMUXC_BASE_ADDR + 0x4b0, 0x00000028)
+# Address
+MXC_DCD_ITEM(5, IOMUXC_BASE_ADDR + 0x464, 0x00000028)
+MXC_DCD_ITEM(6, IOMUXC_BASE_ADDR + 0x490, 0x00000028)
+MXC_DCD_ITEM(7, IOMUXC_BASE_ADDR + 0x74c, 0x00000028)
+# Control
+MXC_DCD_ITEM(8, IOMUXC_BASE_ADDR + 0x494, 0x00000028)
+
+MXC_DCD_ITEM(9, IOMUXC_BASE_ADDR + 0x4a0, 0x00000000)
+
+MXC_DCD_ITEM(10, IOMUXC_BASE_ADDR + 0x4b4, 0x00000028)
+MXC_DCD_ITEM(11, IOMUXC_BASE_ADDR + 0x4b8, 0x00000028)
+MXC_DCD_ITEM(12, IOMUXC_BASE_ADDR + 0x76c, 0x00000028)
+# Data Strobe
+MXC_DCD_ITEM(13, IOMUXC_BASE_ADDR + 0x750, 0x00020000)
+
+MXC_DCD_ITEM(14, IOMUXC_BASE_ADDR + 0x4bc, 0x00000028)
+MXC_DCD_ITEM(15, IOMUXC_BASE_ADDR + 0x4c0, 0x00000028)
+MXC_DCD_ITEM(16, IOMUXC_BASE_ADDR + 0x4c4, 0x00000028)
+MXC_DCD_ITEM(17, IOMUXC_BASE_ADDR + 0x4c8, 0x00000028)
+MXC_DCD_ITEM(18, IOMUXC_BASE_ADDR + 0x4cc, 0x00000028)
+MXC_DCD_ITEM(19, IOMUXC_BASE_ADDR + 0x4d0, 0x00000028)
+MXC_DCD_ITEM(20, IOMUXC_BASE_ADDR + 0x4d4, 0x00000028)
+MXC_DCD_ITEM(21, IOMUXC_BASE_ADDR + 0x4d8, 0x00000028)
+
+MXC_DCD_ITEM(22, IOMUXC_BASE_ADDR + 0x760, 0x00020000)
+
+MXC_DCD_ITEM(23, IOMUXC_BASE_ADDR + 0x764, 0x00000028)
+MXC_DCD_ITEM(24, IOMUXC_BASE_ADDR + 0x770, 0x00000028)
+MXC_DCD_ITEM(25, IOMUXC_BASE_ADDR + 0x778, 0x00000028)
+MXC_DCD_ITEM(26, IOMUXC_BASE_ADDR + 0x77c, 0x00000028)
+MXC_DCD_ITEM(27, IOMUXC_BASE_ADDR + 0x780, 0x00000028)
+MXC_DCD_ITEM(28, IOMUXC_BASE_ADDR + 0x784, 0x00000028)
+MXC_DCD_ITEM(29, IOMUXC_BASE_ADDR + 0x78c, 0x00000028)
+MXC_DCD_ITEM(30, IOMUXC_BASE_ADDR + 0x748, 0x00000028)
+
+MXC_DCD_ITEM(31, IOMUXC_BASE_ADDR + 0x470, 0x00000028)
+MXC_DCD_ITEM(32, IOMUXC_BASE_ADDR + 0x474, 0x00000028)
+MXC_DCD_ITEM(33, IOMUXC_BASE_ADDR + 0x478, 0x00000028)
+MXC_DCD_ITEM(34, IOMUXC_BASE_ADDR + 0x47c, 0x00000028)
+MXC_DCD_ITEM(35, IOMUXC_BASE_ADDR + 0x480, 0x00000028)
+MXC_DCD_ITEM(36, IOMUXC_BASE_ADDR + 0x484, 0x00000028)
+MXC_DCD_ITEM(37, IOMUXC_BASE_ADDR + 0x488, 0x00000028)
+MXC_DCD_ITEM(38, IOMUXC_BASE_ADDR + 0x48c, 0x00000028)
+
+# MMDC_P0_BASE_ADDR = 0x021b0000
+# MMDC_P1_BASE_ADDR = 0x021b4000
+# Calibrations
+# ZQ
+MXC_DCD_ITEM(39, MMDC_P0_BASE_ADDR + 0x800, 0xa1390003)
+
+# write leveling
+MXC_DCD_ITEM(40, MMDC_P0_BASE_ADDR + 0x80c, 0x00550055)
+MXC_DCD_ITEM(41, MMDC_P0_BASE_ADDR + 0x810, 0x00490053)
+MXC_DCD_ITEM(42, MMDC_P1_BASE_ADDR + 0x80c, 0x00230023)
+MXC_DCD_ITEM(43, MMDC_P1_BASE_ADDR + 0x810, 0x0028003A)
+# DQS gating, read delay, write delay calibration values
+# based on calibration compare of 0x00ffff00
+MXC_DCD_ITEM(44, MMDC_P0_BASE_ADDR + 0x83c, 0x02540258)
+MXC_DCD_ITEM(45, MMDC_P0_BASE_ADDR + 0x840, 0x023C023C)
+MXC_DCD_ITEM(46, MMDC_P1_BASE_ADDR + 0x83C, 0x02240230)
+MXC_DCD_ITEM(47, MMDC_P1_BASE_ADDR + 0x840, 0x02200224)
+
+MXC_DCD_ITEM(48, MMDC_P0_BASE_ADDR + 0x848, 0x42424C4C)
+MXC_DCD_ITEM(49, MMDC_P1_BASE_ADDR + 0x848, 0x4040443E)
+
+MXC_DCD_ITEM(50, MMDC_P0_BASE_ADDR + 0x850, 0x3A383036)
+MXC_DCD_ITEM(51, MMDC_P1_BASE_ADDR + 0x850, 0x3034362E)
+
+MXC_DCD_ITEM(52, MMDC_P0_BASE_ADDR + 0x81c, 0x33333333)
+MXC_DCD_ITEM(53, MMDC_P0_BASE_ADDR + 0x820, 0x33333333)
+MXC_DCD_ITEM(54, MMDC_P0_BASE_ADDR + 0x824, 0x33333333)
+MXC_DCD_ITEM(55, MMDC_P0_BASE_ADDR + 0x828, 0x33333333)
+MXC_DCD_ITEM(56, MMDC_P1_BASE_ADDR + 0x81c, 0x33333333)
+MXC_DCD_ITEM(57, MMDC_P1_BASE_ADDR + 0x820, 0x33333333)
+MXC_DCD_ITEM(58, MMDC_P1_BASE_ADDR + 0x824, 0x33333333)
+MXC_DCD_ITEM(59, MMDC_P1_BASE_ADDR + 0x828, 0x33333333)
+
+MXC_DCD_ITEM(60, MMDC_P0_BASE_ADDR + 0x8b8, 0x00000800)
+MXC_DCD_ITEM(61, MMDC_P1_BASE_ADDR + 0x8b8, 0x00000800)
+# MMDC init:
+# in DDR3, 64-bit mode, only MMDC0 is initiated:
+MXC_DCD_ITEM(62, MMDC_P0_BASE_ADDR + 0x004, 0x0002002D)
+MXC_DCD_ITEM(63, MMDC_P0_BASE_ADDR + 0x008, 0x00333040)
+MXC_DCD_ITEM(64, MMDC_P0_BASE_ADDR + 0x00c, 0x3F435313)
+MXC_DCD_ITEM(65, MMDC_P0_BASE_ADDR + 0x010, 0xB66E8B63)
+MXC_DCD_ITEM(66, MMDC_P0_BASE_ADDR + 0x014, 0x01FF00DB)
+MXC_DCD_ITEM(67, MMDC_P0_BASE_ADDR + 0x018, 0x00011740)
+
+MXC_DCD_ITEM(68, MMDC_P0_BASE_ADDR + 0x01c, 0x00008000)
+MXC_DCD_ITEM(69, MMDC_P0_BASE_ADDR + 0x02c, 0x000026d2)
+MXC_DCD_ITEM(70, MMDC_P0_BASE_ADDR + 0x030, 0x00431023)
+MXC_DCD_ITEM(71, MMDC_P0_BASE_ADDR + 0x040, 0x00000027)
+
+MXC_DCD_ITEM(72, MMDC_P0_BASE_ADDR + 0x000, 0x831A0000)
+
+# Initialize 1GB DDR3 - Nanya NT5CB128M16HP
+MXC_DCD_ITEM(73, MMDC_P0_BASE_ADDR + 0x01c, 0x02008032)
+MXC_DCD_ITEM(74, MMDC_P0_BASE_ADDR + 0x01c, 0x00008033)
+MXC_DCD_ITEM(75, MMDC_P0_BASE_ADDR + 0x01c, 0x00048031)
+MXC_DCD_ITEM(76, MMDC_P0_BASE_ADDR + 0x01c, 0x05208030)
+MXC_DCD_ITEM(77, MMDC_P0_BASE_ADDR + 0x01c, 0x04008040)
+
+MXC_DCD_ITEM(78, MMDC_P0_BASE_ADDR + 0x020, 0x00007800)
+
+MXC_DCD_ITEM(79, MMDC_P0_BASE_ADDR + 0x818, 0x00022227)
+MXC_DCD_ITEM(80, MMDC_P1_BASE_ADDR + 0x818, 0x00022227)
+
+MXC_DCD_ITEM(81, MMDC_P0_BASE_ADDR + 0x004, 0x0002556d)
+MXC_DCD_ITEM(82, MMDC_P0_BASE_ADDR + 0x404, 0x00011006)
+MXC_DCD_ITEM(83, MMDC_P0_BASE_ADDR + 0x01c, 0x00000000)
+
diff --git a/board/via/mx6qsm8q60/qsm8q60_mx6dl_2g.cfg b/board/via/mx6qsm8q60/qsm8q60_mx6dl_2g.cfg
new file mode 100644
index 0000000..8d920ed
--- /dev/null
+++ b/board/via/mx6qsm8q60/qsm8q60_mx6dl_2g.cfg
@@ -0,0 +1,129 @@
+
+
+// qsm8q60_imx6dl_2g_ram
+# IOMUXC_BASE_ADDR  = 0x20e0000
+# DDR IO TYPE
+MXC_DCD_ITEM(1, IOMUXC_BASE_ADDR + 0x774, 0x000c0000)
+MXC_DCD_ITEM(2, IOMUXC_BASE_ADDR + 0x754, 0x00000000)
+
+# Clock
+MXC_DCD_ITEM(3, IOMUXC_BASE_ADDR + 0x4ac, 0x00000028)
+MXC_DCD_ITEM(4, IOMUXC_BASE_ADDR + 0x4b0, 0x00000028)
+
+# Address
+MXC_DCD_ITEM(5, IOMUXC_BASE_ADDR + 0x464, 0x00000028)
+MXC_DCD_ITEM(6, IOMUXC_BASE_ADDR + 0x490, 0x00000028)
+MXC_DCD_ITEM(7, IOMUXC_BASE_ADDR + 0x74c, 0x00000028)
+
+# Control
+MXC_DCD_ITEM(8, IOMUXC_BASE_ADDR + 0x494, 0x00000028)
+MXC_DCD_ITEM(9, IOMUXC_BASE_ADDR + 0x4a0, 0x00000000)
+MXC_DCD_ITEM(10, IOMUXC_BASE_ADDR + 0x4b4, 0x00000028)
+MXC_DCD_ITEM(11, IOMUXC_BASE_ADDR + 0x4b8, 0x00000028)
+MXC_DCD_ITEM(12, IOMUXC_BASE_ADDR + 0x76c, 0x00000028)
+
+# Data Strobe
+MXC_DCD_ITEM(13, IOMUXC_BASE_ADDR + 0x750, 0x00020000)
+MXC_DCD_ITEM(14, IOMUXC_BASE_ADDR + 0x4bc, 0x00000028)
+MXC_DCD_ITEM(15, IOMUXC_BASE_ADDR + 0x4c0, 0x00000028)
+MXC_DCD_ITEM(16, IOMUXC_BASE_ADDR + 0x4c4, 0x00000028)
+MXC_DCD_ITEM(17, IOMUXC_BASE_ADDR + 0x4c8, 0x00000028)
+MXC_DCD_ITEM(18, IOMUXC_BASE_ADDR + 0x4cc, 0x00000028)
+MXC_DCD_ITEM(19, IOMUXC_BASE_ADDR + 0x4d0, 0x00000028)
+MXC_DCD_ITEM(20, IOMUXC_BASE_ADDR + 0x4d4, 0x00000028)
+MXC_DCD_ITEM(21, IOMUXC_BASE_ADDR + 0x4d8, 0x00000028)
+
+# Data
+MXC_DCD_ITEM(22, IOMUXC_BASE_ADDR + 0x760, 0x00020000)
+MXC_DCD_ITEM(23, IOMUXC_BASE_ADDR + 0x764, 0x00000028)
+MXC_DCD_ITEM(24, IOMUXC_BASE_ADDR + 0x770, 0x00000028)
+MXC_DCD_ITEM(25, IOMUXC_BASE_ADDR + 0x778, 0x00000028)
+MXC_DCD_ITEM(26, IOMUXC_BASE_ADDR + 0x77c, 0x00000028)
+MXC_DCD_ITEM(27, IOMUXC_BASE_ADDR + 0x780, 0x00000028)
+MXC_DCD_ITEM(28, IOMUXC_BASE_ADDR + 0x784, 0x00000028)
+MXC_DCD_ITEM(29, IOMUXC_BASE_ADDR + 0x78c, 0x00000028)
+MXC_DCD_ITEM(30, IOMUXC_BASE_ADDR + 0x748, 0x00000028)
+
+MXC_DCD_ITEM(31, IOMUXC_BASE_ADDR + 0x470, 0x00000028)
+MXC_DCD_ITEM(32, IOMUXC_BASE_ADDR + 0x474, 0x00000028)
+MXC_DCD_ITEM(33, IOMUXC_BASE_ADDR + 0x478, 0x00000028)
+MXC_DCD_ITEM(34, IOMUXC_BASE_ADDR + 0x47c, 0x00000028)
+MXC_DCD_ITEM(35, IOMUXC_BASE_ADDR + 0x480, 0x00000028)
+MXC_DCD_ITEM(36, IOMUXC_BASE_ADDR + 0x484, 0x00000028)
+MXC_DCD_ITEM(37, IOMUXC_BASE_ADDR + 0x488, 0x00000028)
+MXC_DCD_ITEM(38, IOMUXC_BASE_ADDR + 0x48c, 0x00000028)
+
+# MMDC_P0_BASE_ADDR = 0x021b0000
+# MMDC_P1_BASE_ADDR = 0x021b4000
+# Calibrations
+# ZQ
+MXC_DCD_ITEM(39, MMDC_P0_BASE_ADDR + 0x800, 0xa1390003)
+
+# write leveling
+MXC_DCD_ITEM(40, MMDC_P0_BASE_ADDR + 0x80c, 0x004F004F)
+MXC_DCD_ITEM(41, MMDC_P0_BASE_ADDR + 0x810, 0x0047004F)
+MXC_DCD_ITEM(42, MMDC_P1_BASE_ADDR + 0x80c, 0x002B002F)
+MXC_DCD_ITEM(43, MMDC_P1_BASE_ADDR + 0x810, 0x00290042)
+# DQS gating, read delay, write delay calibration values
+# based on calibration compare of 0x00ffff00
+
+# Read DQS Gating calibration
+MXC_DCD_ITEM(44, MMDC_P0_BASE_ADDR + 0x83c, 0x02440248)
+MXC_DCD_ITEM(45, MMDC_P0_BASE_ADDR + 0x840, 0x02300230)
+MXC_DCD_ITEM(46, MMDC_P1_BASE_ADDR + 0x83C, 0x021C0228)
+MXC_DCD_ITEM(47, MMDC_P1_BASE_ADDR + 0x840, 0x02140214)
+
+# Read calibration
+MXC_DCD_ITEM(48, MMDC_P0_BASE_ADDR + 0x848, 0x4648484A)
+MXC_DCD_ITEM(49, MMDC_P1_BASE_ADDR + 0x848, 0x48464842)
+
+# Write calibration
+MXC_DCD_ITEM(50, MMDC_P0_BASE_ADDR + 0x850, 0x38382E30)
+MXC_DCD_ITEM(51, MMDC_P1_BASE_ADDR + 0x850, 0x3630342A)
+
+# read data bit delay
+MXC_DCD_ITEM(52, MMDC_P0_BASE_ADDR + 0x81c, 0x33333333)
+MXC_DCD_ITEM(53, MMDC_P0_BASE_ADDR + 0x820, 0x33333333)
+MXC_DCD_ITEM(54, MMDC_P0_BASE_ADDR + 0x824, 0x33333333)
+MXC_DCD_ITEM(55, MMDC_P0_BASE_ADDR + 0x828, 0x33333333)
+MXC_DCD_ITEM(56, MMDC_P1_BASE_ADDR + 0x81c, 0x33333333)
+MXC_DCD_ITEM(57, MMDC_P1_BASE_ADDR + 0x820, 0x33333333)
+MXC_DCD_ITEM(58, MMDC_P1_BASE_ADDR + 0x824, 0x33333333)
+MXC_DCD_ITEM(59, MMDC_P1_BASE_ADDR + 0x828, 0x33333333)
+
+# Complete calibration by forced measurement
+MXC_DCD_ITEM(60, MMDC_P0_BASE_ADDR + 0x8b8, 0x00000800)
+MXC_DCD_ITEM(61, MMDC_P1_BASE_ADDR + 0x8b8, 0x00000800)
+
+# MMDC init:
+# in DDR3, 64-bit mode, only MMDC0 is initiated:
+MXC_DCD_ITEM(62, MMDC_P0_BASE_ADDR + 0x004, 0x0002002D)
+MXC_DCD_ITEM(63, MMDC_P0_BASE_ADDR + 0x008, 0x00333040)
+MXC_DCD_ITEM(64, MMDC_P0_BASE_ADDR + 0x00c, 0x676B52F3)
+MXC_DCD_ITEM(65, MMDC_P0_BASE_ADDR + 0x010, 0xB66D8B63)
+MXC_DCD_ITEM(66, MMDC_P0_BASE_ADDR + 0x014, 0x01FF00DB)
+MXC_DCD_ITEM(67, MMDC_P0_BASE_ADDR + 0x018, 0x00011740)
+
+MXC_DCD_ITEM(68, MMDC_P0_BASE_ADDR + 0x01c, 0x00008000)
+MXC_DCD_ITEM(69, MMDC_P0_BASE_ADDR + 0x02c, 0x000026D2)
+MXC_DCD_ITEM(70, MMDC_P0_BASE_ADDR + 0x030, 0x006B1023)
+MXC_DCD_ITEM(71, MMDC_P0_BASE_ADDR + 0x040, 0x00000047)
+MXC_DCD_ITEM(72, MMDC_P0_BASE_ADDR + 0x000, 0x841A0000)
+
+# Mode register writes
+# Initialize 2GB DDR3 - Nanya NT5CC256M16CP-DII
+MXC_DCD_ITEM(73, MMDC_P0_BASE_ADDR + 0x01c, 0x02808032)
+MXC_DCD_ITEM(74, MMDC_P0_BASE_ADDR + 0x01c, 0x00008033)
+MXC_DCD_ITEM(75, MMDC_P0_BASE_ADDR + 0x01c, 0x00048031)
+MXC_DCD_ITEM(76, MMDC_P0_BASE_ADDR + 0x01c, 0x15208030)
+MXC_DCD_ITEM(77, MMDC_P0_BASE_ADDR + 0x01c, 0x04008040)
+
+MXC_DCD_ITEM(78, MMDC_P0_BASE_ADDR + 0x020, 0x00007800)
+
+MXC_DCD_ITEM(79, MMDC_P0_BASE_ADDR + 0x818, 0x00022227)
+MXC_DCD_ITEM(80, MMDC_P1_BASE_ADDR + 0x818, 0x00022227)
+
+MXC_DCD_ITEM(81, MMDC_P0_BASE_ADDR + 0x004, 0x0002556D)
+MXC_DCD_ITEM(82, MMDC_P0_BASE_ADDR + 0x404, 0x00011006)
+MXC_DCD_ITEM(83, MMDC_P0_BASE_ADDR + 0x01c, 0x00000000)
+
diff --git a/board/via/mx6qsm8q60/qsm8q60_mx6q_1g.cfg b/board/via/mx6qsm8q60/qsm8q60_mx6q_1g.cfg
new file mode 100644
index 0000000..0de0ded
--- /dev/null
+++ b/board/via/mx6qsm8q60/qsm8q60_mx6q_1g.cfg
@@ -0,0 +1,149 @@
+
+
+// imx6q_1g_ram
+// Ken modified Nanya 1G registers based on VAB-820 R.1
+
+#define VAB820_SDQSx 0x00000028
+MXC_DCD_ITEM(1, IOMUXC_BASE_ADDR + 0x5a8, VAB820_SDQSx)
+MXC_DCD_ITEM(2, IOMUXC_BASE_ADDR + 0x5b0, VAB820_SDQSx)
+MXC_DCD_ITEM(3, IOMUXC_BASE_ADDR + 0x524, VAB820_SDQSx)
+MXC_DCD_ITEM(4, IOMUXC_BASE_ADDR + 0x51c, VAB820_SDQSx)
+
+MXC_DCD_ITEM(5, IOMUXC_BASE_ADDR + 0x518, VAB820_SDQSx)
+MXC_DCD_ITEM(6, IOMUXC_BASE_ADDR + 0x50c, VAB820_SDQSx)
+MXC_DCD_ITEM(7, IOMUXC_BASE_ADDR + 0x5b8, VAB820_SDQSx)
+MXC_DCD_ITEM(8, IOMUXC_BASE_ADDR + 0x5c0, VAB820_SDQSx)
+
+#define VAB820_DQM 0x00000028
+MXC_DCD_ITEM(9, IOMUXC_BASE_ADDR + 0x5ac, VAB820_DQM)
+MXC_DCD_ITEM(10, IOMUXC_BASE_ADDR + 0x5b4, VAB820_DQM)
+MXC_DCD_ITEM(11, IOMUXC_BASE_ADDR + 0x528, VAB820_DQM)
+MXC_DCD_ITEM(12, IOMUXC_BASE_ADDR + 0x520, VAB820_DQM)
+
+MXC_DCD_ITEM(13, IOMUXC_BASE_ADDR + 0x514, VAB820_DQM)
+MXC_DCD_ITEM(14, IOMUXC_BASE_ADDR + 0x510, VAB820_DQM)
+MXC_DCD_ITEM(15, IOMUXC_BASE_ADDR + 0x5bc, VAB820_DQM)
+MXC_DCD_ITEM(16, IOMUXC_BASE_ADDR + 0x5c4, VAB820_DQM)
+
+MXC_DCD_ITEM(17, IOMUXC_BASE_ADDR + 0x56c, 0x00000028)
+MXC_DCD_ITEM(18, IOMUXC_BASE_ADDR + 0x578, 0x00000028)
+
+#define VAB820_SDCLKx 0x00000028
+MXC_DCD_ITEM(19, IOMUXC_BASE_ADDR + 0x588, VAB820_SDCLKx)
+MXC_DCD_ITEM(20, IOMUXC_BASE_ADDR + 0x594, VAB820_SDCLKx)
+
+// unknow register
+MXC_DCD_ITEM(21, IOMUXC_BASE_ADDR + 0x57c, 0x00000028)
+MXC_DCD_ITEM(22, IOMUXC_BASE_ADDR + 0x590, 0x00003000)
+MXC_DCD_ITEM(23, IOMUXC_BASE_ADDR + 0x598, 0x00003000)
+MXC_DCD_ITEM(24, IOMUXC_BASE_ADDR + 0x58c, 0x00000000)
+
+#define VAB820_SDODTx 0x00000028
+MXC_DCD_ITEM(25, IOMUXC_BASE_ADDR + 0x59c, VAB820_SDODTx)
+MXC_DCD_ITEM(26, IOMUXC_BASE_ADDR + 0x5a0, VAB820_SDODTx)
+
+#define VAB820_BxDS 0x28
+MXC_DCD_ITEM(27, IOMUXC_BASE_ADDR + 0x784, VAB820_BxDS)
+MXC_DCD_ITEM(28, IOMUXC_BASE_ADDR + 0x788, VAB820_BxDS)
+
+MXC_DCD_ITEM(29, IOMUXC_BASE_ADDR + 0x794, VAB820_BxDS)
+MXC_DCD_ITEM(30, IOMUXC_BASE_ADDR + 0x79c, VAB820_BxDS)
+MXC_DCD_ITEM(31, IOMUXC_BASE_ADDR + 0x7a0, VAB820_BxDS)
+MXC_DCD_ITEM(32, IOMUXC_BASE_ADDR + 0x7a4, VAB820_BxDS)
+
+MXC_DCD_ITEM(33, IOMUXC_BASE_ADDR + 0x7a8, VAB820_BxDS)
+MXC_DCD_ITEM(34, IOMUXC_BASE_ADDR + 0x748, VAB820_BxDS)
+
+#define VAB820_ADD_CTL_DS 0x00000028
+MXC_DCD_ITEM(35, IOMUXC_BASE_ADDR + 0x74c, VAB820_ADD_CTL_DS)
+MXC_DCD_ITEM(36, IOMUXC_BASE_ADDR + 0x750, 0x00020000)
+
+MXC_DCD_ITEM(37, IOMUXC_BASE_ADDR + 0x758, 0x00000000)
+MXC_DCD_ITEM(38, IOMUXC_BASE_ADDR + 0x774, 0x00020000)
+MXC_DCD_ITEM(39, IOMUXC_BASE_ADDR + 0x78c, VAB820_ADD_CTL_DS)
+MXC_DCD_ITEM(40, IOMUXC_BASE_ADDR + 0x798, 0x000C0000)
+
+MXC_DCD_ITEM(41, MMDC_P0_BASE_ADDR + 0x81c, 0x33333333)
+MXC_DCD_ITEM(42, MMDC_P0_BASE_ADDR + 0x820, 0x33333333)
+MXC_DCD_ITEM(43, MMDC_P0_BASE_ADDR + 0x824, 0x33333333)
+MXC_DCD_ITEM(44, MMDC_P0_BASE_ADDR + 0x828, 0x33333333)
+
+MXC_DCD_ITEM(45, MMDC_P1_BASE_ADDR + 0x81c, 0x33333333)
+MXC_DCD_ITEM(46, MMDC_P1_BASE_ADDR + 0x820, 0x33333333)
+MXC_DCD_ITEM(47, MMDC_P1_BASE_ADDR + 0x824, 0x33333333)
+MXC_DCD_ITEM(48, MMDC_P1_BASE_ADDR + 0x828, 0x33333333)
+
+MXC_DCD_ITEM(49, MMDC_P0_BASE_ADDR + 0x018, 0x00001740)
+
+MXC_DCD_ITEM(50, MMDC_P0_BASE_ADDR + 0x01c, 0x00008000)
+MXC_DCD_ITEM(51, MMDC_P0_BASE_ADDR + 0x00c, 0x54597974)
+MXC_DCD_ITEM(52, MMDC_P0_BASE_ADDR + 0x010, 0xDB538F64)
+MXC_DCD_ITEM(53, MMDC_P0_BASE_ADDR + 0x014, 0x01FF00DB)
+MXC_DCD_ITEM(54, MMDC_P0_BASE_ADDR + 0x02c, 0x000026D2)
+// MDOR
+MXC_DCD_ITEM(55, MMDC_P0_BASE_ADDR + 0x030, 0x00591023)
+MXC_DCD_ITEM(56, MMDC_P0_BASE_ADDR + 0x008, 0x09444040)
+// MDPDC
+MXC_DCD_ITEM(57, MMDC_P0_BASE_ADDR + 0x004, 0x00020036)
+// MDASP CS0_END
+MXC_DCD_ITEM(58, MMDC_P0_BASE_ADDR + 0x040, 0x00000027)
+// MDCTL
+MXC_DCD_ITEM(59, MMDC_P0_BASE_ADDR + 0x000, 0x831A0000)
+// MR2
+MXC_DCD_ITEM(60, MMDC_P0_BASE_ADDR + 0x01c, 0x02088032)
+MXC_DCD_ITEM(61, MMDC_P0_BASE_ADDR + 0x01c, 0x0288803A)
+// MR3
+MXC_DCD_ITEM(62, MMDC_P0_BASE_ADDR + 0x01c, 0x00008033)
+MXC_DCD_ITEM(63, MMDC_P0_BASE_ADDR + 0x01c, 0x0000803B)
+// MR1
+MXC_DCD_ITEM(64, MMDC_P0_BASE_ADDR + 0x01c, 0x00048031)
+MXC_DCD_ITEM(65, MMDC_P0_BASE_ADDR + 0x01c, 0x00048039)
+// MR0
+MXC_DCD_ITEM(66, MMDC_P0_BASE_ADDR + 0x01c, 0x09308030)
+MXC_DCD_ITEM(67, MMDC_P0_BASE_ADDR + 0x01c, 0x09308038)
+// ZQ calibration
+MXC_DCD_ITEM(68, MMDC_P0_BASE_ADDR + 0x01c, 0x04008040)
+MXC_DCD_ITEM(69, MMDC_P0_BASE_ADDR + 0x01c, 0x04008048)
+// ZQ
+MXC_DCD_ITEM(70, MMDC_P0_BASE_ADDR + 0x800, 0xA1380003)
+MXC_DCD_ITEM(71, MMDC_P1_BASE_ADDR + 0x800, 0xA1380003)
+//// final DDR setup
+// MMDC0_MDREF
+MXC_DCD_ITEM(72, MMDC_P0_BASE_ADDR + 0x020, 0x00007800)
+// MPODTCTRL
+MXC_DCD_ITEM(73, MMDC_P0_BASE_ADDR + 0x818, 0x00022227)
+MXC_DCD_ITEM(74, MMDC_P1_BASE_ADDR + 0x818, 0x00022227)
+//Read DQS Gating calibration
+MXC_DCD_ITEM(75, MMDC_P0_BASE_ADDR + 0x83c, 0x03340348)
+MXC_DCD_ITEM(76, MMDC_P0_BASE_ADDR + 0x840, 0x0236032C)
+MXC_DCD_ITEM(77, MMDC_P1_BASE_ADDR + 0x83c, 0x03340344)
+MXC_DCD_ITEM(78, MMDC_P1_BASE_ADDR + 0x840, 0x032C0300)
+//Read calibration
+MXC_DCD_ITEM(79, MMDC_P0_BASE_ADDR + 0x848, 0x32282E30)
+MXC_DCD_ITEM(80, MMDC_P1_BASE_ADDR + 0x848, 0x302A283A)
+//Write calibration
+MXC_DCD_ITEM(81, MMDC_P0_BASE_ADDR + 0x850, 0x3A363E38)
+MXC_DCD_ITEM(82, MMDC_P1_BASE_ADDR + 0x850, 0x40303E36)
+// MPWLDECTRLx
+MXC_DCD_ITEM(83, MMDC_P0_BASE_ADDR + 0x80c, 0x001C0013)
+MXC_DCD_ITEM(84, MMDC_P0_BASE_ADDR + 0x810, 0x0022001C)
+MXC_DCD_ITEM(85, MMDC_P1_BASE_ADDR + 0x80c, 0x00160025)
+MXC_DCD_ITEM(86, MMDC_P1_BASE_ADDR + 0x810, 0x000C001C)
+// MPMUR0
+MXC_DCD_ITEM(87, MMDC_P0_BASE_ADDR + 0x8b8, 0x00000800)
+MXC_DCD_ITEM(88, MMDC_P1_BASE_ADDR + 0x8b8, 0x00000800)
+
+MXC_DCD_ITEM(89, MMDC_P0_BASE_ADDR + 0x01c, 0x00000000)
+MXC_DCD_ITEM(90, MMDC_P0_BASE_ADDR + 0x404, 0x00011006)
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/board/via/mx6qsm8q60/qsm8q60_mx6q_2g.cfg b/board/via/mx6qsm8q60/qsm8q60_mx6q_2g.cfg
new file mode 100644
index 0000000..f44334b
--- /dev/null
+++ b/board/via/mx6qsm8q60/qsm8q60_mx6q_2g.cfg
@@ -0,0 +1,131 @@
+
+
+// imx6q_2g_ram
+#define VAB820_SDQSx 0x00000028
+MXC_DCD_ITEM(1, IOMUXC_BASE_ADDR + 0x5a8, VAB820_SDQSx)
+MXC_DCD_ITEM(2, IOMUXC_BASE_ADDR + 0x5b0, VAB820_SDQSx)
+MXC_DCD_ITEM(3, IOMUXC_BASE_ADDR + 0x524, VAB820_SDQSx)
+MXC_DCD_ITEM(4, IOMUXC_BASE_ADDR + 0x51c, VAB820_SDQSx)
+MXC_DCD_ITEM(5, IOMUXC_BASE_ADDR + 0x518, VAB820_SDQSx)
+MXC_DCD_ITEM(6, IOMUXC_BASE_ADDR + 0x50c, VAB820_SDQSx)
+MXC_DCD_ITEM(7, IOMUXC_BASE_ADDR + 0x5b8, VAB820_SDQSx)
+MXC_DCD_ITEM(8, IOMUXC_BASE_ADDR + 0x5c0, VAB820_SDQSx)
+#define VAB820_DQM 0x00000028
+MXC_DCD_ITEM(9, IOMUXC_BASE_ADDR + 0x5ac, VAB820_DQM)
+MXC_DCD_ITEM(10, IOMUXC_BASE_ADDR + 0x5b4, VAB820_DQM)
+MXC_DCD_ITEM(11, IOMUXC_BASE_ADDR + 0x528, VAB820_DQM)
+MXC_DCD_ITEM(12, IOMUXC_BASE_ADDR + 0x520, VAB820_DQM)
+MXC_DCD_ITEM(13, IOMUXC_BASE_ADDR + 0x514, VAB820_DQM)
+MXC_DCD_ITEM(14, IOMUXC_BASE_ADDR + 0x510, VAB820_DQM)
+MXC_DCD_ITEM(15, IOMUXC_BASE_ADDR + 0x5bc, VAB820_DQM)
+MXC_DCD_ITEM(16, IOMUXC_BASE_ADDR + 0x5c4, VAB820_DQM)
+// CAS
+MXC_DCD_ITEM(17, IOMUXC_BASE_ADDR + 0x56c, 0x00000028)
+// RAS
+MXC_DCD_ITEM(18, IOMUXC_BASE_ADDR + 0x578, 0x00000028)
+#define VAB820_SDCLKx 0x00000028
+MXC_DCD_ITEM(19, IOMUXC_BASE_ADDR + 0x588, VAB820_SDCLKx)
+MXC_DCD_ITEM(20, IOMUXC_BASE_ADDR + 0x594, VAB820_SDCLKx)
+MXC_DCD_ITEM(21, IOMUXC_BASE_ADDR + 0x57c, 0x00000028)
+MXC_DCD_ITEM(22, IOMUXC_BASE_ADDR + 0x590, 0x00003000)
+MXC_DCD_ITEM(23, IOMUXC_BASE_ADDR + 0x598, 0x00003000)
+MXC_DCD_ITEM(24, IOMUXC_BASE_ADDR + 0x58c, 0x00000000)
+#define VAB820_SDODTx 0x00000028
+MXC_DCD_ITEM(25, IOMUXC_BASE_ADDR + 0x59c, VAB820_SDODTx)
+MXC_DCD_ITEM(26, IOMUXC_BASE_ADDR + 0x5a0, VAB820_SDODTx)
+#define VAB820_BxDS 0x28
+MXC_DCD_ITEM(27, IOMUXC_BASE_ADDR + 0x784, VAB820_BxDS)
+MXC_DCD_ITEM(28, IOMUXC_BASE_ADDR + 0x788, VAB820_BxDS)
+MXC_DCD_ITEM(29, IOMUXC_BASE_ADDR + 0x794, VAB820_BxDS)
+MXC_DCD_ITEM(30, IOMUXC_BASE_ADDR + 0x79c, VAB820_BxDS)
+MXC_DCD_ITEM(31, IOMUXC_BASE_ADDR + 0x7a0, VAB820_BxDS)
+MXC_DCD_ITEM(32, IOMUXC_BASE_ADDR + 0x7a4, VAB820_BxDS)
+MXC_DCD_ITEM(33, IOMUXC_BASE_ADDR + 0x7a8, VAB820_BxDS)
+MXC_DCD_ITEM(34, IOMUXC_BASE_ADDR + 0x748, VAB820_BxDS)
+#define VAB820_ADD_CTL_DS 0x00000028
+MXC_DCD_ITEM(35, IOMUXC_BASE_ADDR + 0x74c, VAB820_ADD_CTL_DS)
+MXC_DCD_ITEM(36, IOMUXC_BASE_ADDR + 0x750, 0x00020000)
+MXC_DCD_ITEM(37, IOMUXC_BASE_ADDR + 0x758, 0x00000000)
+MXC_DCD_ITEM(38, IOMUXC_BASE_ADDR + 0x774, 0x00020000)
+MXC_DCD_ITEM(39, IOMUXC_BASE_ADDR + 0x78c, VAB820_ADD_CTL_DS)
+MXC_DCD_ITEM(40, IOMUXC_BASE_ADDR + 0x798, 0x000C0000)
+
+MXC_DCD_ITEM(41, MMDC_P0_BASE_ADDR + 0x81c, 0x33333333)
+MXC_DCD_ITEM(42, MMDC_P0_BASE_ADDR + 0x820, 0x33333333)
+MXC_DCD_ITEM(43, MMDC_P0_BASE_ADDR + 0x824, 0x33333333)
+MXC_DCD_ITEM(44, MMDC_P0_BASE_ADDR + 0x828, 0x33333333)
+
+MXC_DCD_ITEM(45, MMDC_P1_BASE_ADDR + 0x81c, 0x33333333)
+MXC_DCD_ITEM(46, MMDC_P1_BASE_ADDR + 0x820, 0x33333333)
+MXC_DCD_ITEM(47, MMDC_P1_BASE_ADDR + 0x824, 0x33333333)
+MXC_DCD_ITEM(48, MMDC_P1_BASE_ADDR + 0x828, 0x33333333)
+// MDMISC
+MXC_DCD_ITEM(49, MMDC_P0_BASE_ADDR + 0x018, 0x00081740)
+
+MXC_DCD_ITEM(50, MMDC_P0_BASE_ADDR + 0x01c, 0x00008000)
+// MDCFG0
+MXC_DCD_ITEM(51, MMDC_P0_BASE_ADDR + 0x00c, 0x898E7955)
+// MDCFG1
+MXC_DCD_ITEM(52, MMDC_P0_BASE_ADDR + 0x010, 0xFF328F64)
+// MDCFG2
+MXC_DCD_ITEM(53, MMDC_P0_BASE_ADDR + 0x014, 0x01FF00DB)
+MXC_DCD_ITEM(54, MMDC_P0_BASE_ADDR + 0x02c, 0x000026D2)
+// MDOR
+MXC_DCD_ITEM(55, MMDC_P0_BASE_ADDR + 0x030, 0x008E1023)
+MXC_DCD_ITEM(56, MMDC_P0_BASE_ADDR + 0x008, 0x09444040)
+// MDPDC
+MXC_DCD_ITEM(57, MMDC_P0_BASE_ADDR + 0x004, 0x00020036)
+// MDASP
+MXC_DCD_ITEM(58, MMDC_P0_BASE_ADDR + 0x040, 0x00000047)
+// MDCTL
+MXC_DCD_ITEM(59, MMDC_P0_BASE_ADDR + 0x000, 0x841A0000)
+// MR2
+MXC_DCD_ITEM(60, MMDC_P0_BASE_ADDR + 0x01c, 0x04088032)
+MXC_DCD_ITEM(61, MMDC_P0_BASE_ADDR + 0x01c, 0x0408803A)
+// MR3
+MXC_DCD_ITEM(62, MMDC_P0_BASE_ADDR + 0x01c, 0x00008033)
+MXC_DCD_ITEM(63, MMDC_P0_BASE_ADDR + 0x01c, 0x0000803B)
+// MR1
+MXC_DCD_ITEM(64, MMDC_P0_BASE_ADDR + 0x01c, 0x00428031)
+MXC_DCD_ITEM(65, MMDC_P0_BASE_ADDR + 0x01c, 0x00428039)
+// MR0
+MXC_DCD_ITEM(66, MMDC_P0_BASE_ADDR + 0x01c, 0x09408030)
+MXC_DCD_ITEM(67, MMDC_P0_BASE_ADDR + 0x01c, 0x09408038)
+// ZQ calibration
+MXC_DCD_ITEM(68, MMDC_P0_BASE_ADDR + 0x01c, 0x04008040)
+MXC_DCD_ITEM(69, MMDC_P0_BASE_ADDR + 0x01c, 0x04008048)
+// ZQ
+MXC_DCD_ITEM(70, MMDC_P0_BASE_ADDR + 0x800, 0xA1390003)
+MXC_DCD_ITEM(71, MMDC_P1_BASE_ADDR + 0x800, 0xA1390003)
+//// final DDR setup
+// MMDC0_MDREF
+MXC_DCD_ITEM(72, MMDC_P0_BASE_ADDR + 0x020, 0x00005800)
+// MPODTCTRL
+MXC_DCD_ITEM(73, MMDC_P0_BASE_ADDR + 0x818, 0x00000007)
+MXC_DCD_ITEM(74, MMDC_P1_BASE_ADDR + 0x818, 0x00000007)
+//Read DQS Gating calibration
+MXC_DCD_ITEM(75, MMDC_P0_BASE_ADDR + 0x83c, 0x03200338)
+MXC_DCD_ITEM(76, MMDC_P0_BASE_ADDR + 0x840, 0x024A0314)
+MXC_DCD_ITEM(77, MMDC_P1_BASE_ADDR + 0x83c, 0x03280340)
+MXC_DCD_ITEM(78, MMDC_P1_BASE_ADDR + 0x840, 0x03280270)
+//Read calibration
+MXC_DCD_ITEM(79, MMDC_P0_BASE_ADDR + 0x848, 0x342C3232)
+MXC_DCD_ITEM(80, MMDC_P1_BASE_ADDR + 0x848, 0x342E283A)
+//Write calibration
+MXC_DCD_ITEM(81, MMDC_P0_BASE_ADDR + 0x850, 0x3E363C34)
+MXC_DCD_ITEM(82, MMDC_P1_BASE_ADDR + 0x850, 0x44344636)
+// MPWLDECTRLx
+MXC_DCD_ITEM(83, MMDC_P0_BASE_ADDR + 0x80c, 0x00190019)
+MXC_DCD_ITEM(84, MMDC_P0_BASE_ADDR + 0x810, 0x001F001D)
+MXC_DCD_ITEM(85, MMDC_P1_BASE_ADDR + 0x80c, 0x0015001F)
+MXC_DCD_ITEM(86, MMDC_P1_BASE_ADDR + 0x810, 0x00110026)
+// MPMUR0
+MXC_DCD_ITEM(87, MMDC_P0_BASE_ADDR + 0x8b8, 0x00000800)
+MXC_DCD_ITEM(88, MMDC_P1_BASE_ADDR + 0x8b8, 0x00000800)
+
+MXC_DCD_ITEM(89, MMDC_P0_BASE_ADDR + 0x01c, 0x00000000)
+MXC_DCD_ITEM(90, MMDC_P0_BASE_ADDR + 0x404, 0x00011006)
+
+
+
+
diff --git a/board/via/mx6qsm8q60/qsm8q60_mx6q_4g.cfg b/board/via/mx6qsm8q60/qsm8q60_mx6q_4g.cfg
new file mode 100644
index 0000000..78e18c4
--- /dev/null
+++ b/board/via/mx6qsm8q60/qsm8q60_mx6q_4g.cfg
@@ -0,0 +1,138 @@
+
+
+// imx6q_4g_ram
+#define VAB820_SDQSx 0x00000028
+MXC_DCD_ITEM(1, IOMUXC_BASE_ADDR + 0x5a8, VAB820_SDQSx)
+MXC_DCD_ITEM(2, IOMUXC_BASE_ADDR + 0x5b0, VAB820_SDQSx)
+MXC_DCD_ITEM(3, IOMUXC_BASE_ADDR + 0x524, VAB820_SDQSx)
+MXC_DCD_ITEM(4, IOMUXC_BASE_ADDR + 0x51c, VAB820_SDQSx)
+MXC_DCD_ITEM(5, IOMUXC_BASE_ADDR + 0x518, VAB820_SDQSx)
+MXC_DCD_ITEM(6, IOMUXC_BASE_ADDR + 0x50c, VAB820_SDQSx)
+MXC_DCD_ITEM(7, IOMUXC_BASE_ADDR + 0x5b8, VAB820_SDQSx)
+MXC_DCD_ITEM(8, IOMUXC_BASE_ADDR + 0x5c0, VAB820_SDQSx)
+#define VAB820_DQM 0x00000028
+MXC_DCD_ITEM(9, IOMUXC_BASE_ADDR + 0x5ac, VAB820_DQM)
+MXC_DCD_ITEM(10, IOMUXC_BASE_ADDR + 0x5b4, VAB820_DQM)
+MXC_DCD_ITEM(11, IOMUXC_BASE_ADDR + 0x528, VAB820_DQM)
+MXC_DCD_ITEM(12, IOMUXC_BASE_ADDR + 0x520, VAB820_DQM)
+MXC_DCD_ITEM(13, IOMUXC_BASE_ADDR + 0x514, VAB820_DQM)
+MXC_DCD_ITEM(14, IOMUXC_BASE_ADDR + 0x510, VAB820_DQM)
+MXC_DCD_ITEM(15, IOMUXC_BASE_ADDR + 0x5bc, VAB820_DQM)
+MXC_DCD_ITEM(16, IOMUXC_BASE_ADDR + 0x5c4, VAB820_DQM)
+// CAS
+MXC_DCD_ITEM(17, IOMUXC_BASE_ADDR + 0x56c, 0x00000028)
+// RAS
+MXC_DCD_ITEM(18, IOMUXC_BASE_ADDR + 0x578, 0x00000028)
+#define VAB820_SDCLKx 0x00000028
+MXC_DCD_ITEM(19, IOMUXC_BASE_ADDR + 0x588, VAB820_SDCLKx)
+MXC_DCD_ITEM(20, IOMUXC_BASE_ADDR + 0x594, VAB820_SDCLKx)
+MXC_DCD_ITEM(21, IOMUXC_BASE_ADDR + 0x57c, 0x00000028)
+// steven: unknown 0x590, 0x598
+MXC_DCD_ITEM(22, IOMUXC_BASE_ADDR + 0x590, 0x00003000)
+MXC_DCD_ITEM(23, IOMUXC_BASE_ADDR + 0x598, 0x00003000)
+MXC_DCD_ITEM(24, IOMUXC_BASE_ADDR + 0x58c, 0x00000000)
+#define VAB820_SDODTx 0x00000028
+MXC_DCD_ITEM(25, IOMUXC_BASE_ADDR + 0x59c, VAB820_SDODTx)
+MXC_DCD_ITEM(26, IOMUXC_BASE_ADDR + 0x5a0, VAB820_SDODTx)
+#define VAB820_BxDS 0x28
+MXC_DCD_ITEM(27, IOMUXC_BASE_ADDR + 0x784, VAB820_BxDS)
+MXC_DCD_ITEM(28, IOMUXC_BASE_ADDR + 0x788, VAB820_BxDS)
+MXC_DCD_ITEM(29, IOMUXC_BASE_ADDR + 0x794, VAB820_BxDS)
+MXC_DCD_ITEM(30, IOMUXC_BASE_ADDR + 0x79c, VAB820_BxDS)
+MXC_DCD_ITEM(31, IOMUXC_BASE_ADDR + 0x7a0, VAB820_BxDS)
+MXC_DCD_ITEM(32, IOMUXC_BASE_ADDR + 0x7a4, VAB820_BxDS)
+MXC_DCD_ITEM(33, IOMUXC_BASE_ADDR + 0x7a8, VAB820_BxDS)
+MXC_DCD_ITEM(34, IOMUXC_BASE_ADDR + 0x748, VAB820_BxDS)
+#define VAB820_ADD_CTL_DS 0x00000028
+MXC_DCD_ITEM(35, IOMUXC_BASE_ADDR + 0x74c, VAB820_ADD_CTL_DS)
+MXC_DCD_ITEM(36, IOMUXC_BASE_ADDR + 0x750, 0x00020000)
+MXC_DCD_ITEM(37, IOMUXC_BASE_ADDR + 0x758, 0x00000000)
+MXC_DCD_ITEM(38, IOMUXC_BASE_ADDR + 0x774, 0x00020000)
+MXC_DCD_ITEM(39, IOMUXC_BASE_ADDR + 0x78c, VAB820_ADD_CTL_DS)
+MXC_DCD_ITEM(40, IOMUXC_BASE_ADDR + 0x798, 0x000C0000)
+
+MXC_DCD_ITEM(41, MMDC_P0_BASE_ADDR + 0x81c, 0x33333333)
+MXC_DCD_ITEM(42, MMDC_P0_BASE_ADDR + 0x820, 0x33333333)
+MXC_DCD_ITEM(43, MMDC_P0_BASE_ADDR + 0x824, 0x33333333)
+MXC_DCD_ITEM(44, MMDC_P0_BASE_ADDR + 0x828, 0x33333333)
+
+MXC_DCD_ITEM(45, MMDC_P1_BASE_ADDR + 0x81c, 0x33333333)
+MXC_DCD_ITEM(46, MMDC_P1_BASE_ADDR + 0x820, 0x33333333)
+MXC_DCD_ITEM(47, MMDC_P1_BASE_ADDR + 0x824, 0x33333333)
+MXC_DCD_ITEM(48, MMDC_P1_BASE_ADDR + 0x828, 0x33333333)
+// MDMISC steven 4g
+MXC_DCD_ITEM(49, MMDC_P0_BASE_ADDR + 0x018, 0x00011740)
+
+MXC_DCD_ITEM(50, MMDC_P0_BASE_ADDR + 0x01c, 0x00008000)
+// MDCFG0 steven 4g
+MXC_DCD_ITEM(51, MMDC_P0_BASE_ADDR + 0x00c, 0xB8BE7955)
+// MDCFG1
+MXC_DCD_ITEM(52, MMDC_P0_BASE_ADDR + 0x010, 0xFF328F64)
+// MDCFG2
+MXC_DCD_ITEM(53, MMDC_P0_BASE_ADDR + 0x014, 0x01FF00DB)
+MXC_DCD_ITEM(54, MMDC_P0_BASE_ADDR + 0x02c, 0x000026D2)
+// MDOR steven 4g
+MXC_DCD_ITEM(55, MMDC_P0_BASE_ADDR + 0x030, 0x00BE1023)
+MXC_DCD_ITEM(56, MMDC_P0_BASE_ADDR + 0x008, 0x09444040)
+// MDPDC
+MXC_DCD_ITEM(57, MMDC_P0_BASE_ADDR + 0x004, 0x00020036)
+// MDASP, steven: 47 -> 3F
+MXC_DCD_ITEM(58, MMDC_P0_BASE_ADDR + 0x040, 0x0000003F)
+// MDCTL steven 4g
+MXC_DCD_ITEM(59, MMDC_P0_BASE_ADDR + 0x000, 0xC41A0000)
+// MR2 steven 4g
+MXC_DCD_ITEM(60, MMDC_P0_BASE_ADDR + 0x01c, 0x04888032)
+MXC_DCD_ITEM(61, MMDC_P0_BASE_ADDR + 0x01c, 0x0488803A)
+// MR3
+MXC_DCD_ITEM(62, MMDC_P0_BASE_ADDR + 0x01c, 0x00008033)
+MXC_DCD_ITEM(63, MMDC_P0_BASE_ADDR + 0x01c, 0x0000803B)
+// MR1
+MXC_DCD_ITEM(64, MMDC_P0_BASE_ADDR + 0x01c, 0x00048031)
+MXC_DCD_ITEM(65, MMDC_P0_BASE_ADDR + 0x01c, 0x00048039)
+// MR0
+MXC_DCD_ITEM(66, MMDC_P0_BASE_ADDR + 0x01c, 0x09408030)
+MXC_DCD_ITEM(67, MMDC_P0_BASE_ADDR + 0x01c, 0x09408038)
+// ZQ calibration
+MXC_DCD_ITEM(68, MMDC_P0_BASE_ADDR + 0x01c, 0x04008040)
+MXC_DCD_ITEM(69, MMDC_P0_BASE_ADDR + 0x01c, 0x04008048)
+// ZQ
+MXC_DCD_ITEM(70, MMDC_P0_BASE_ADDR + 0x800, 0xA1390003)
+MXC_DCD_ITEM(71, MMDC_P1_BASE_ADDR + 0x800, 0xA1390003)
+//// final DDR setup
+// MMDC0_MDREF steven 4g
+MXC_DCD_ITEM(72, MMDC_P0_BASE_ADDR + 0x020, 0x00007800)
+// MPODTCTRL steven 4g
+MXC_DCD_ITEM(73, MMDC_P0_BASE_ADDR + 0x818, 0x00011117)
+MXC_DCD_ITEM(74, MMDC_P1_BASE_ADDR + 0x818, 0x00011117)
+//Read DQS Gating calibration
+MXC_DCD_ITEM(75, MMDC_P0_BASE_ADDR + 0x83c, 0x0324033C)
+MXC_DCD_ITEM(76, MMDC_P0_BASE_ADDR + 0x840, 0x0320031C)
+MXC_DCD_ITEM(77, MMDC_P1_BASE_ADDR + 0x83c, 0x03280334)
+MXC_DCD_ITEM(78, MMDC_P1_BASE_ADDR + 0x840, 0x03280264)
+//Read calibration
+MXC_DCD_ITEM(79, MMDC_P0_BASE_ADDR + 0x848, 0x48384046)
+MXC_DCD_ITEM(80, MMDC_P1_BASE_ADDR + 0x848, 0x4238364A)
+//Write calibration
+MXC_DCD_ITEM(81, MMDC_P0_BASE_ADDR + 0x850, 0x40404842)
+MXC_DCD_ITEM(82, MMDC_P1_BASE_ADDR + 0x850, 0x443A4A3A)
+// MPWLDECTRLx
+// steven: 4G no calibration
+#MXC_DCD_ITEM(83, MMDC_P0_BASE_ADDR + 0x80c, 0x00190019)
+#MXC_DCD_ITEM(84, MMDC_P0_BASE_ADDR + 0x810, 0x001F001D)
+#MXC_DCD_ITEM(85, MMDC_P1_BASE_ADDR + 0x80c, 0x0015001F)
+#MXC_DCD_ITEM(86, MMDC_P1_BASE_ADDR + 0x810, 0x00110026)
+
+MXC_DCD_ITEM(83, MMDC_P0_BASE_ADDR + 0x80c, 0x00000000)
+MXC_DCD_ITEM(84, MMDC_P0_BASE_ADDR + 0x810, 0x00000000)
+MXC_DCD_ITEM(85, MMDC_P1_BASE_ADDR + 0x80c, 0x00000000)
+MXC_DCD_ITEM(86, MMDC_P1_BASE_ADDR + 0x810, 0x00000000)
+// MPMUR0
+MXC_DCD_ITEM(87, MMDC_P0_BASE_ADDR + 0x8b8, 0x00000800)
+MXC_DCD_ITEM(88, MMDC_P1_BASE_ADDR + 0x8b8, 0x00000800)
+
+MXC_DCD_ITEM(89, MMDC_P0_BASE_ADDR + 0x01c, 0x00000000)
+MXC_DCD_ITEM(90, MMDC_P0_BASE_ADDR + 0x404, 0x00011006)
+
+
+
+
diff --git a/board/via/mx6qsm8q60/viatools.c b/board/via/mx6qsm8q60/viatools.c
new file mode 100644
index 0000000..a0f2e68
--- /dev/null
+++ b/board/via/mx6qsm8q60/viatools.c
@@ -0,0 +1,117 @@
+
+
+static int sTextAttribute = 0;
+enum { taNormal=0, taBold=1, taUnderscore=4, taBlink=5};
+static void text_attribute(int textAttribute)
+{
+	sTextAttribute = textAttribute;
+}
+
+enum { 
+	clNone=0, clRed=31, clGreen, clYellow, clBlue, clMagenta, clCyan=36
+};
+static void color_print(const char* p, int color)
+{
+	printf("\x1b[%d;%dm%s\x1b[0m", sTextAttribute, color, p);
+}
+
+u32 __weak mx6_chip_rev(void) {
+	return get_cpu_rev() & 0xff;
+}
+static void show_cpu(void) {
+	printf("CPU: %s, rev = 0x%x\n",
+ 		(cpu_is_mx6dl() ? "MX6DL" : "MX6Q"), mx6_chip_rev());
+}
+
+static void show_ram(void) {
+	int nRamSize = 1024;
+	u32 reg = readl(GPIO6_BASE_ADDR + GPIO_PSR);
+
+	switch ( reg & 0x600 ) {
+		case 0x200: nRamSize = 3840; break;
+		case 0x400: nRamSize = (2 * 1024 ); break;
+		default: nRamSize = (1 * 1024); break;
+	}
+	printf("RAM: size = %d MB\n", nRamSize);
+}
+
+static void show_samsung_emmc_info(struct mmc *mmc) {
+	printf("Samsung, ");
+	switch (mmc->cid[1]) {
+		case 0x34473146: /* 1st ID = 0x4d */
+			 printf("eMMC 4.4, 4GB\n"); break;
+		case 0x594d4433: /* 1st ID = 0x34 */
+			printf("eMMC 5.0, 4GB\n"); break;
+		case 0x38473147: /* 1st ID = 0x4d */
+			printf("eMMC 5.0, 8GB\n"); break;
+		default:
+			printf("Unknown Product Name = 0x%08x\n", mmc->cid[1]);
+	}
+}
+
+static void show_hynix_emmc_info(struct mmc *mmc) {
+	printf("Hynix, ");
+	switch (mmc->cid[1]) {
+		case 0x38473264: /* 1st ID = 0x48 */
+			printf("eMMC 4.4, 8GB\n"); break;
+		default:
+			printf("Unknown Product Name = 0x%08x\n", mmc->cid[1]);
+	}
+}
+
+static void show_emmc(void) {
+	struct mmc *mmc = find_mmc_device(1);
+	mmc_init(mmc);
+	printf("eMMC: ");
+	switch (mmc->cid[0] >> 24) {
+		case 0x15: show_samsung_emmc_info(mmc); break;
+		case 0x90: show_hynix_emmc_info(mmc); break;
+		default:
+			printf("Unknown Manufacturer ID = 0x%x, Product Name = 0x%08x\n"
+			, mmc->cid[0] >> 24, mmc->cid[1]); break;
+	}
+}
+
+static void show_spi(void) {
+	printf("SPI ROM: ");
+	run_command("sf probe", 0);
+}
+
+static void show_hw_info(void)
+{
+	printf("\n\n");
+	show_cpu();
+	show_ram();
+	show_emmc();
+	show_spi();
+	printf("\n\n");
+}
+
+int do_viatools(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int ch;
+	printf("\n\n");
+	while(1){
+		text_attribute(taBold);
+		color_print("VIA tools\n", clCyan);
+		text_attribute(taNormal);
+		printf("===================================\n");
+		printf("1. hardware information\n");
+		printf("others. exit\n");
+		printf("===================================\n");
+		printf("choose : ");
+		ch = getc(); printf("%c\n", ch);
+		//printf("your input = %c, 0x%x\n", ch, ch);
+		switch (ch) {
+			case '1': show_hw_info(); break;
+			default: return 0;
+		}
+	}
+	return 0;
+}
+
+U_BOOT_CMD(
+	viatools, CONFIG_SYS_MAXARGS, 0, do_viatools,
+	"VIA tools",
+	"- some useful tools"
+);
diff --git a/boards.cfg b/boards.cfg
index 2383d04..6f44c55 100644
--- a/boards.cfg
+++ b/boards.cfg
@@ -341,6 +341,7 @@ Active  arm         armv7          mx6         freescale       mx6qsabreauto
 Active  arm         armv7          mx6         freescale       mx6qsabreauto       mx6solosabreautoandroid_nand                        mx6qsabreauto:IMX_CONFIG=board/freescale/mx6qsabreauto/mx6solo.cfg,MX6SOLO,DEFAULT_FDT_FILE="imx6dl-sabreauto.dtb",DDR_MB=1024,SYS_BOOT_NAND,SYS_NOSMP="nosmp",ANDROID_SUPPORT                Fabio Estevam <fabio.estevam@freescale.com>
 Active  arm         armv7          mx6         freescale       mx6qsabreauto       mx6qsabreauto_sata                        mx6qsabreauto:IMX_CONFIG=board/freescale/mx6qsabreauto/mx6q.cfg,MX6Q,DEFAULT_FDT_FILE="imx6q-sabreauto.dtb",DDR_MB=2048,SYS_BOOT_SATA                                                          Fabio Estevam <fabio.estevam@freescale.com>
 Active  arm         armv7          mx6         freescale       mx6sabresd          mx6dlsabresd                         mx6sabresd:IMX_CONFIG=board/freescale/mx6sabresd/mx6dl_4x_mt41j128.cfg,MX6DL,DEFAULT_FDT_FILE="imx6dl-sabresd.dtb",DDR_MB=1024,SYS_USE_SPINOR                                                  Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         via             mx6qsm8q60          mx6qsm8q60                           mx6qsm8q60:IMX_CONFIG=board/via/mx6qsm8q60/qsm8q60_dram.cfg,MX6QDL,DEFAULT_FDT_FILE="imx6dl-qsm8q60.dtb",SYS_USE_SPINOR                                                                             -
 Active  arm         armv7          mx6         freescale       mx6sabresd          mx6dlsabresdandroid                         mx6sabresd:IMX_CONFIG=board/freescale/mx6sabresd/mx6dl_4x_mt41j128.cfg,MX6DL,DEFAULT_FDT_FILE="imx6dl-sabresd.dtb",DDR_MB=1024,SYS_USE_SPINOR,ANDROID_SUPPORT                                                  Fabio Estevam <fabio.estevam@freescale.com>
 Active  arm         armv7          mx6         freescale       mx6sabresd          mx6qsabresd                          mx6sabresd:IMX_CONFIG=board/freescale/imx/ddr/mx6q_4x_mt41j128.cfg,MX6Q,DEFAULT_FDT_FILE="imx6q-sabresd.dtb",DDR_MB=1024,SYS_USE_SPINOR                                                           Fabio Estevam <fabio.estevam@freescale.com>
 Active  arm         armv7          mx6         freescale       mx6sabresd          mx6qsabresdandroid                          mx6sabresd:IMX_CONFIG=board/freescale/imx/ddr/mx6q_4x_mt41j128.cfg,MX6Q,DEFAULT_FDT_FILE="imx6q-sabresd.dtb",DDR_MB=1024,SYS_USE_SPINOR,ANDROID_SUPPORT                                                           Fabio Estevam <fabio.estevam@freescale.com>
diff --git a/common/cmd_nvedit.c b/common/cmd_nvedit.c
index 1b06bf2..f5e73e7 100644
--- a/common/cmd_nvedit.c
+++ b/common/cmd_nvedit.c
@@ -685,6 +685,10 @@ ulong getenv_ulong(const char *name, int base, ulong default_val)
 
 #ifndef CONFIG_SPL_BUILD
 #if defined(CONFIG_CMD_SAVEENV) && !defined(CONFIG_ENV_IS_NOWHERE)
+/* Chris Added: default: not destroy environment */
+__weak int in_destroyenv(void) { 
+	return 0; 
+}
 static int do_env_save(cmd_tbl_t *cmdtp, int flag, int argc,
 		       char * const argv[])
 {
diff --git a/common/env_mmc.c b/common/env_mmc.c
index 0d4e8a2..7a506f8 100644
--- a/common/env_mmc.c
+++ b/common/env_mmc.c
@@ -148,6 +148,12 @@ int saveenv(void)
 
 	env_new->crc = crc32(0, &env_new->data[0], ENV_SIZE);
 
+	{
+		/* Chris Added: support destroyenv */
+		int in_destroyenv(void);
+		if ( in_destroyenv()) { env_new->crc++; }
+	}
+
 #ifdef CONFIG_ENV_OFFSET_REDUND
 	env_new->flags	= ++env_flags; /* increase the serial */
 
diff --git a/common/env_sf.c b/common/env_sf.c
index be270f2..e6e2d4c 100644
--- a/common/env_sf.c
+++ b/common/env_sf.c
@@ -267,7 +267,11 @@ int saveenv(void)
 		goto done;
 	}
 	env_new.crc = crc32(0, env_new.data, ENV_SIZE);
-
+	{
+                /* Chris Added: support destroyenv */
+                int in_destroyenv(void);
+                if(in_destroyenv()) {env_new.crc++;}
+	}
 	puts("Erasing SPI flash...");
 	ret = spi_flash_erase(env_flash, CONFIG_ENV_OFFSET,
 		sector * CONFIG_ENV_SECT_SIZE);
diff --git a/include/configs/mx6qsm8q60.h b/include/configs/mx6qsm8q60.h
new file mode 100644
index 0000000..70e07a8
--- /dev/null
+++ b/include/configs/mx6qsm8q60.h
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2012-2014 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6Q SabreSD board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MX6QSM8Q60_CONFIG_H
+#define __MX6QSM8Q60_CONFIG_H
+
+#include <asm/arch/imx-regs.h>
+#include <asm/imx-common/gpio.h>
+
+#define CONFIG_MACH_TYPE	3980
+#define CONFIG_IDENT_STRING	" QSM-8Q60 ver:1.0.1"
+#define CONFIG_MXC_UART_BASE	UART2_BASE
+#define CONFIG_CONSOLE_DEV		"ttymxc1"
+#define CONFIG_I2C_MULTI_BUS	/* Chris Added: multiple i2c bus */
+
+#include "mx6qsm8q60_common.h"
+
+/* USB Configs */
+#define CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS   0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 1 /* Enabled USB controller number */
+
+/* Chris Added: NUM = 2, 0=sdcard, 1=mmc */
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_SYS_MMC_ENV_DEV		0	/* 0 = SD2 */
+#define CONFIG_SYS_MMC_ENV_PART         0       /* user partition */
+#define CONFIG_USE_PLUGIN	/* Chris Added: DRAM setting */
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_SF_DEFAULT_CS   (0|(IMX_GPIO_NR(3, 19)<<8))
+#endif
+
+/*
+ * imx6 q/dl/solo pcie would be failed to work properly in kernel, if
+ * the pcie module is iniialized/enumerated both in uboot and linux
+ * kernel.
+ * rootcause:imx6 q/dl/solo pcie don't have the reset mechanism.
+ * it is only be RESET by the POR. So, the pcie module only be
+ * initialized/enumerated once in one POR.
+ * Set to use pcie in kernel defaultly, mask the pcie config here.
+ * Remove the mask freely, if the uboot pcie functions, rather than
+ * the kernel's, are required.
+ */
+/* #define CONFIG_CMD_PCI */
+#ifdef CONFIG_CMD_PCI
+#define CONFIG_PCI
+#define CONFIG_PCI_PNP
+#define CONFIG_PCI_SCAN_SHOW
+#define CONFIG_PCIE_IMX
+#define CONFIG_PCIE_IMX_PERST_GPIO	IMX_GPIO_NR(7, 12)
+#define CONFIG_PCIE_IMX_POWER_GPIO	IMX_GPIO_NR(3, 19)
+#endif
+
+/*#define CONFIG_SPLASH_SCREEN*/
+/*#define CONFIG_MXC_EPDC*/
+
+/*
+ * SPLASH SCREEN Configs
+ */
+#if defined(CONFIG_SPLASH_SCREEN) && defined(CONFIG_MXC_EPDC)
+	/*
+	 * Framebuffer and LCD
+	 */
+	#define CONFIG_CMD_BMP
+	#define CONFIG_LCD
+	#define CONFIG_FB_BASE				(CONFIG_SYS_TEXT_BASE + 0x300000)
+	#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+	#undef LCD_TEST_PATTERN
+	/* #define CONFIG_SPLASH_IS_IN_MMC			1 */
+	#define LCD_BPP					LCD_MONOCHROME
+	/* #define CONFIG_SPLASH_SCREEN_ALIGN		1 */
+
+	#define CONFIG_WORKING_BUF_ADDR			(CONFIG_SYS_TEXT_BASE + 0x100000)
+	#define CONFIG_WAVEFORM_BUF_ADDR		(CONFIG_SYS_TEXT_BASE + 0x200000)
+	#define CONFIG_WAVEFORM_FILE_OFFSET		0x600000
+	#define CONFIG_WAVEFORM_FILE_SIZE		0xF0A00
+	#define CONFIG_WAVEFORM_FILE_IN_MMC
+
+#ifdef CONFIG_SPLASH_IS_IN_MMC
+	#define CONFIG_SPLASH_IMG_OFFSET		0x4c000
+	#define CONFIG_SPLASH_IMG_SIZE			0x19000
+#endif
+#endif /* CONFIG_SPLASH_SCREEN && CONFIG_MXC_EPDC */
+
+#endif                         /* __MX6QSM8Q60_CONFIG_H */
diff --git a/include/configs/mx6qsm8q60_common.h b/include/configs/mx6qsm8q60_common.h
new file mode 100644
index 0000000..3481068
--- /dev/null
+++ b/include/configs/mx6qsm8q60_common.h
@@ -0,0 +1,431 @@
+/*
+ * Copyright (C) 2012-2014 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6Q SabreSD board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MX6QSM8Q60_COMMON_CONFIG_H
+#define __MX6QSM8Q60_COMMON_CONFIG_H
+
+#define CONFIG_MX6
+
+#ifdef CONFIG_MX6SOLO
+#define CONFIG_MX6DL
+#endif
+
+/* Chris: DRAM, uncomment for PLUGIN mode support */
+#define CONFIG_USE_PLUGIN 
+
+/* uncomment for SECURE mode support */
+/* #define CONFIG_SECURE_BOOT */
+
+#include "mx6_common.h"
+#include <linux/sizes.h>
+
+#define CONFIG_SYS_GENERIC_BOARD
+#define CONFIG_DISPLAY_CPUINFO
+#define CONFIG_DISPLAY_BOARDINFO
+
+#include <asm/arch/imx-regs.h>
+#include <asm/imx-common/gpio.h>
+
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+#define CONFIG_REVISION_TAG
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(10 * SZ_1M)
+
+#define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_BOARD_LATE_INIT
+#define CONFIG_MXC_GPIO
+
+#define CONFIG_MXC_UART
+
+#define CONFIG_CMD_FUSE
+#ifdef CONFIG_CMD_FUSE
+#define CONFIG_MXC_OCOTP
+#endif
+
+/* MMC Configs */
+#define CONFIG_FSL_ESDHC
+#define CONFIG_FSL_USDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR      0
+
+#define CONFIG_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_BOUNCE_BUFFER
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+
+#define CONFIG_SUPPORT_EMMC_BOOT /* eMMC specific */
+
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_NET
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define IMX_FEC_BASE			ENET_BASE_ADDR
+#define CONFIG_FEC_XCV_TYPE		RGMII
+#define CONFIG_ETHPRIME			"FEC"
+#define CONFIG_FEC_MXC_PHYADDR		7	//Chris
+
+#define CONFIG_PHYLIB
+/* Chris Added */
+#define CONFIG_PHY_MICREL
+#define CONFIG_PHY_MICREL_KSZ9031
+//#define CONFIG_PHY_ATHEROS
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_CONS_INDEX              1
+#define CONFIG_BAUDRATE                        115200
+
+/* Command definition */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_BMODE
+#define CONFIG_CMD_BOOTZ
+#define CONFIG_CMD_SETEXPR
+#undef CONFIG_CMD_IMLS
+
+#define CONFIG_BOOTDELAY               3	//Chris: 1 -> 3
+
+#define CONFIG_LOADADDR                        0x12000000
+#define CONFIG_SYS_TEXT_BASE           0x17800000
+#define CONFIG_SYS_MMC_IMG_LOAD_PART	1
+
+#ifdef CONFIG_SYS_BOOT_NAND
+#define CONFIG_MFG_NAND_PARTITION "mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),-(rootfs) "
+#else
+#define CONFIG_MFG_NAND_PARTITION ""
+#endif
+
+#define CONFIG_MFG_ENV_SETTINGS \
+	"mfgtool_args=setenv bootargs console=" CONFIG_CONSOLE_DEV ",115200 " \
+		"rdinit=/linuxrc " \
+		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
+		"g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
+		"g_mass_storage.iSerialNumber=\"\" "\
+		"enable_wait_mode=off "\
+		CONFIG_MFG_NAND_PARTITION \
+		"\0" \
+		"initrd_addr=0x12C00000\0" \
+		"initrd_high=0xffffffff\0" \
+		"bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
+
+#if defined(CONFIG_SYS_BOOT_NAND)
+	/*
+	 * The dts also enables the WEIN NOR which is mtd0.
+	 * So the partions' layout for NAND is:
+	 *     mtd1: 16M      (uboot)
+	 *     mtd2: 16M      (kernel)
+	 *     mtd3: 16M      (dtb)
+	 *     mtd4: left     (rootfs)
+	 */
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	"fdt_addr=0x18000000\0" \
+	"fdt_high=0xffffffff\0"	  \
+	"bootargs=console=" CONFIG_CONSOLE_DEV ",115200 ubi.mtd=4 "  \
+		"root=ubi0:rootfs rootfstype=ubifs "		     \
+		"mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),-(rootfs)\0"\
+	"bootcmd=nand read ${loadaddr} 0x4000000 0x800000;"\
+		"nand read ${fdt_addr} 0x5000000 0x100000;"\
+		"bootz ${loadaddr} - ${fdt_addr}\0"
+
+#elif defined(CONFIG_SYS_BOOT_SATA)
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		CONFIG_MFG_ENV_SETTINGS \
+		"fdt_addr=0x18000000\0" \
+		"fdt_high=0xffffffff\0"   \
+		"bootargs=console=" CONFIG_CONSOLE_DEV ",115200 \0"\
+		"bootargs_sata=setenv bootargs ${bootargs} " \
+			"root=/dev/sda1 rootwait rw \0" \
+		"bootcmd_sata=run bootargs_sata; sata init; " \
+			"sata read ${loadaddr} 0x800  0x4000; " \
+			"sata read ${fdt_addr} 0x8000 0x800; " \
+			"bootz ${loadaddr} - ${fdt_addr} \0" \
+		"bootcmd=run bootcmd_sata \0"
+
+#else
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	"script=boot.scr\0" \
+	"image=zImage\0" \
+	"fdt_file=" CONFIG_DEFAULT_FDT_FILE "\0" \
+	"fdt_addr=0x18000000\0" \
+	"boot_fdt=try\0" \
+	"ip_dyn=yes\0" \
+	"console=" CONFIG_CONSOLE_DEV "\0" \
+	"fdt_high=0xffffffff\0"	  \
+	"initrd_high=0xffffffff\0" \
+	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
+	"mmcpart=" __stringify(CONFIG_SYS_MMC_IMG_LOAD_PART) "\0" \
+	"mmcautodetect=yes\0" \
+	"update_sd_firmware=" \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"if mmc dev ${mmcdev}; then "	\
+			"if ${get_cmd} ${update_sd_firmware_filename}; then " \
+				"setexpr fw_sz ${filesize} / 0x200; " \
+				"setexpr fw_sz ${fw_sz} + 1; "	\
+				"mmc write ${loadaddr} 0x2 ${fw_sz}; " \
+			"fi; "	\
+		"fi\0" \
+	"hdmi=video=mxcfb0:dev=hdmi,1920x1080M@60,bpp=32\0" \
+	"lvds_auo_g070=video=mxcfb0:dev=ldb,480C60,if=RGB24 ldb=sep0\0" \
+	"lvds_auo_g104=video=mxcfb0:dev=ldb,LDB-XGA,if=RGB24 ldb=sin0\0" \
+	"lvds_auo_g220=video=mxcfb0:dev=ldb,LDB-WSXGA+,if=RGB24 ldb=spl0\0" \
+	"lvds_qa=video=mxcfb0:dev=ldb,LDB-SXGA,if=RGB24 ldb=spl0\0" \
+	"lvds=video=mxcfb0:dev=ldb,LDB-XGA,if=RGB24 ldb=sin0\0" \
+	"hdmilvds=video=mxcfb0:dev=hdmi,1920x1080@60,bpp=32 video=mxcfb1:dev,LDB-SXGA,if=RGB24 ldb=spl0\0" \
+	"output_display=video=mxcfb0:dev=hdmi,1920x1080M@60,bpp=32\0" \
+	"o_hdmi=setenv output_display ${hdmi}\0" \
+	"o_lvdsg070=setenv output_display ${lvds_auo_g070}\0" \
+	"o_lvdsg104=setenv output_display ${lvds_auo_g104}\0" \
+	"o_lvdsg220=setenv output_display ${lvds_auo_g220}\0" \
+	"o_lvdsqa=setenv output_display ${lvds_qa}\0" \
+	"o_hdmilvds=setenv output_display ${hdmilvds}\0" \
+	"mmcargs=setenv bootargs console=${console},${baudrate} ${output_display} root=${mmcroot}\0" \
+	"loadbootscript=" \
+		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
+	"bootscript=echo Running bootscript from ${mmcname} ...; " \
+		"source\0" \
+	"loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
+	"loadfdt=if cpudetect; then setenv fdt_file imx6q-qsm8q60.dtb; else setenv fdt_file imx6dl-qsm8q60.dtb; fi;" \
+	"fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
+	"mmcboot=echo Booting from ${mmcname} ...; " \
+		"run mmcargs; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if run loadfdt; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0" \
+	"netargs=setenv bootargs console=${console},${baudrate} " \
+		"root=/dev/nfs " \
+		"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0" \
+	"netboot=echo Booting from net ...; " \
+		"run netargs; " \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"${get_cmd} ${image}; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0" \
+	"bootcmd_main=setenv mmcroot /dev/mmcblk${rootdev}p2 rootwait rw;" \
+		"mmc dev ${mmcdev};" \
+		"if mmc rescan; then " \
+			"if run loadbootscript; then " \
+			"run bootscript; " \
+			"else " \
+				"if run loadimage; then " \
+					"run mmcboot; " \
+				"else run netboot; " \
+				"fi; " \
+			"fi; " \
+		"else run netboot; fi\0" \
+	"bootcmd_sd=setenv mmcdev 0; setenv rootdev 1; setenv mmcname sdcard; run bootcmd_main;\0" \
+	"bootcmd_mmc=setenv mmcdev 1; setenv rootdev 0; setenv mmcname mmc; run bootcmd_main;\0" \
+	"bootcmd_auto=if run loadimage; then run bootcmd_sd; else run bootcmd_mmc; fi;\0"
+
+#define CONFIG_BOOTCOMMAND \
+	"run bootcmd_auto"
+#endif
+
+#define CONFIG_ARP_TIMEOUT     200UL
+
+/* Miscellaneous configurable options */
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2     "> "
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_SYS_CBSIZE              1024
+
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_MAXARGS             256
+#define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE
+
+#define CONFIG_CMD_MEMTEST
+#define CONFIG_SYS_MEMTEST_START       0x10000000
+#define CONFIG_SYS_MEMTEST_END         0x10010000
+#define CONFIG_SYS_MEMTEST_SCRATCH     0x10800000
+
+#define CONFIG_SYS_LOAD_ADDR           CONFIG_LOADADDR
+
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_STACKSIZE               (128 * 1024)
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS           1
+#define PHYS_SDRAM                     MMDC0_ARB_BASE_ADDR
+
+#define CONFIG_SYS_SDRAM_BASE          PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR       IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE       IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+/* FLASH and environment organization */
+#define CONFIG_SYS_NO_FLASH
+
+#define CONFIG_ENV_SIZE			(8 * 1024)
+
+/* Chris: use SPIROM, defined from boards.cfg */
+/* #define CONFIG_SYS_USE_SPINOR */
+/* Chris: environment is in SPIROM */
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+/* #define CONFIG_ENV_IS_IN_MMC */
+
+#ifdef CONFIG_CMD_SATA
+#define CONFIG_DWC_AHSATA
+#define CONFIG_SYS_SATA_MAX_DEVICE	1
+#define CONFIG_DWC_AHSATA_PORT_ID	0
+#define CONFIG_DWC_AHSATA_BASE_ADDR	SATA_ARB_BASE_ADDR
+#define CONFIG_LBA48
+#define CONFIG_LIBATA
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+/* Chris: support SST, WINBOND, MXIC */
+#define CONFIG_SPI_FLASH_STMICRO
+#define CONFIG_SPI_FLASH_SST	/* Chris Added */
+#define CONFIG_SPI_FLASH_WINBOND
+#define CONFIG_SPI_FLASH_MACRONIX
+#define CONFIG_MXC_SPI
+#define CONFIG_SF_DEFAULT_BUS  0
+#define CONFIG_SF_DEFAULT_SPEED 25000000	//Chris: 20000000 -> 25000000
+#define CONFIG_SF_DEFAULT_MODE (SPI_MODE_0)
+#endif
+
+#ifdef CONFIG_SYS_USE_EIMNOR
+#undef CONFIG_SYS_NO_FLASH
+#define CONFIG_SYS_FLASH_BASE           WEIM_ARB_BASE_ADDR
+#define CONFIG_SYS_FLASH_SECT_SIZE     (128 * 1024)
+#define CONFIG_SYS_MAX_FLASH_BANKS 1    /* max number of memory banks */
+#define CONFIG_SYS_MAX_FLASH_SECT 256   /* max number of sectors on one chip */
+#define CONFIG_SYS_FLASH_CFI            /* Flash memory is CFI compliant */
+#define CONFIG_FLASH_CFI_DRIVER         /* Use drivers/cfi_flash.c */
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE /* Use buffered writes*/
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+#define CONFIG_CMD_NAND
+#define CONFIG_CMD_NAND_TRIMFFS
+
+/* NAND stuff */
+#define CONFIG_NAND_MXS
+#define CONFIG_SYS_MAX_NAND_DEVICE     1
+#define CONFIG_SYS_NAND_BASE           0x40000000
+#define CONFIG_SYS_NAND_5_ADDR_CYCLE
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+
+/* DMA stuff, needed for GPMI/MXS NAND support */
+#define CONFIG_APBH_DMA
+#define CONFIG_APBH_DMA_BURST
+#define CONFIG_APBH_DMA_BURST8
+#endif
+
+#if defined(CONFIG_ENV_IS_IN_MMC)
+/* Chris Added: use 768, not 8*64 */
+#define CONFIG_ENV_OFFSET		(768 * 1024)
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_OFFSET              (768 * 1024)
+#define CONFIG_ENV_SECT_SIZE           (64 * 1024)
+#define CONFIG_ENV_SPI_BUS             CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS              CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE            CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ          CONFIG_SF_DEFAULT_SPEED
+#elif defined(CONFIG_ENV_IS_IN_FLASH)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_SIZE                        CONFIG_SYS_FLASH_SECT_SIZE
+#define CONFIG_ENV_SECT_SIZE           CONFIG_SYS_FLASH_SECT_SIZE
+#define CONFIG_ENV_OFFSET              (4 * CONFIG_SYS_FLASH_SECT_SIZE)
+#elif defined(CONFIG_ENV_IS_IN_NAND)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_OFFSET              (8 << 20)
+#define CONFIG_ENV_SECT_SIZE           (128 << 10)
+#define CONFIG_ENV_SIZE                        CONFIG_ENV_SECT_SIZE
+#elif defined(CONFIG_ENV_IS_IN_SATA)
+#define CONFIG_ENV_OFFSET		(768 * 1024)
+#define CONFIG_SATA_ENV_DEV		0
+#define CONFIG_SYS_DCACHE_OFF /* remove when sata driver support cache */
+#endif
+
+#define CONFIG_OF_LIBFDT
+
+#ifndef CONFIG_SYS_DCACHE_OFF
+#define CONFIG_CMD_CACHE
+#endif
+
+/*
+ * I2C configs
+ */
+#define CONFIG_CMD_I2C
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_SPEED		100000
+
+/* Framebuffer */
+#define CONFIG_VIDEO
+#define CONFIG_VIDEO_IPUV3
+#define CONFIG_CFB_CONSOLE
+#define CONFIG_VGA_AS_SINGLE_DEVICE
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+#define CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE
+#define CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define CONFIG_BMP_16BPP
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_VIDEO_BMP_LOGO
+#ifdef CONFIG_MX6DL
+#define CONFIG_IPUV3_CLK 198000000
+#else
+#define CONFIG_IPUV3_CLK 264000000
+#endif
+#define CONFIG_IMX_HDMI
+
+#if defined(CONFIG_ANDROID_SUPPORT)
+#include "mx6sabreandroid_common.h"
+#endif
+
+#endif                         /* __MX6QSM8Q60_COMMON_CONFIG_H */
diff --git a/net/nfs.h b/net/nfs.h
index 53451db..fd5a3c5 100644
--- a/net/nfs.h
+++ b/net/nfs.h
@@ -12,6 +12,7 @@
 #define PROG_PORTMAP    100000
 #define PROG_NFS        100003
 #define PROG_MOUNT      100005
+#define CONFIG_NFS_TIMEOUT 10000UL
 
 #define MSG_CALL        0
 #define MSG_REPLY       1
